{"version":3,"file":"XElement.min.js","sources":["../src/safeEval.js","../src/utils.js","../src/parseVars.js","../src/watchProxy.js","../src/watch.js","../src/WeakMultiMap.js","../src/createEl.js","../src/xelement.js","../src/bindings.js","../src/XElement.js"],"sourcesContent":["var Cache = function() {\r\n\tvar self = this;\r\n\tthis.map = new Map();\r\n\r\n\tthis.get = function(key, val) {\r\n\t\tlet result = self.map.get(key);\r\n\t\tif (!result) {\r\n\t\t\tself.map.set(key, result = val());\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\r\n\t// TODO\r\n\t//this.remove = function(key) {};\r\n};\r\n\r\nvar safeEvalCache = new Cache();\r\n\r\n\r\n/**\r\n * Evaluate expr, but allow undefined variables.\r\n * @param expr {string}\r\n * @param args {object}\r\n * @param isStatements {boolean=false}\r\n * @returns {*} */\r\nfunction safeEval(expr, args, isStatements) {\r\n\r\n\tlet code = isStatements ? expr : 'return (' + expr + ')';\r\n\tif (args && Object.keys(args).length) {\r\n\r\n\t\t// Convert args object to var a=arguments[0][name] assignments\r\n\t\tlet argAssignments = [];\r\n\t\tfor (let name in args)\r\n\t\t\targAssignments.push(name + '=arguments[0][\"' + name.replace(/\"/g, '\\\"') + '\"]');\r\n\r\n\t\tcode = 'var ' + argAssignments.join(',') + ';' + code;\r\n\t}\r\n\r\n\ttry {\r\n\t\t//return Function('return (' + expr + ')').call(this);\r\n\t\tlet lazyEval = function() {\r\n\t\t\treturn Function(code);\r\n\t\t};\r\n\t\treturn safeEvalCache.get(code, lazyEval).call(this, args);\r\n\t}\r\n\tcatch (e) { // Don't fail for null values.\r\n\t\tif (!(e instanceof TypeError) || (!e.message.match('undefined'))) {\r\n\t\t\t//#IFDEV\r\n\t\t\te.message += ' in expression \"' + code + '\"';\r\n\t\t\t//#ENDIF\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nexport {safeEval}","/**\r\n * Shortened version of this answer: stackoverflow.com/a/18751951\r\n * @type {string[]} */\r\nvar eventNames = Object.keys(document.__proto__.__proto__)\r\n\t.filter((x) => x.startsWith('on'))\r\n\t.map(   (x) => x.slice(2));\r\nvar eventNamesMap = {};\r\nfor (let eventName of eventNames)\r\n\teventNamesMap['on'+eventName] = true;\r\n\r\n\r\n//#IFDEV\r\nclass XElementError extends Error {\r\n\tconstructor(msg) {\r\n\t\tsuper(msg);\r\n\t}\r\n}\r\n//#ENDIF\r\n\r\n\r\nvar removeProxy = (obj) => (obj && obj.$removeProxy) || obj;\r\n\r\n/**\r\n * Return true if the two arrays have the same items in the same order.\r\n * @param array1 {*[]}\r\n * @param array2 {*[]}\r\n * @param deep {boolean=false}\r\n * @returns {boolean} */\r\nvar arrayEq = (array1, array2, deep) => {\r\n\tif (!array1 || !array2 || array1.length !== array2.length)\r\n\t\treturn false;\r\n\r\n\tarray2 = removeProxy(array2);\r\n\treturn removeProxy(array1).every((value, index) => {\r\n\t\tif (deep && Array.isArray(value))\r\n\t\t\treturn arrayEq(value, array2[index]);\r\n\r\n\t\treturn removeProxy(value) === removeProxy(array2[index])\r\n\t})\r\n};\r\n\r\n\r\n/**\r\n * Returns true if obj has at least one key defined.\r\n * @param {object} obj\r\n * @returns {boolean} */\r\nvar hasKeys = (obj) => {\r\n\tfor (let item in obj)\r\n\t\treturn true;\r\n\treturn false;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Return the array as a quoted csv string.\r\n * @param array {string[]}\r\n * @returns {string} */\r\nvar csv = (array) => JSON.stringify(array).slice(1, -1); // slice() to remove starting and ending [].\r\n\r\n\r\n/**\r\n * @param obj {*}\r\n * @returns {boolean} */\r\nvar isObj = (obj) => obj && typeof obj === 'object'; // Make sure it's not null, since typof null === 'object'.\r\n\r\n/**\r\n * Is name a valid attribute for el.\r\n * @param el {HTMLElement}\r\n * @param name {string}\r\n * @returns {boolean} */\r\nvar isValidAttribute = (el, name) => {\r\n\tif ((name.startsWith('data-') || name.startsWith('x-') ||el.hasAttribute(name)) ||\r\n\t\t(name.startsWith('on') && eventNames.includes(name.slice(2))))\r\n\t\treturn true;\r\n\r\n\tif (name in el)\r\n\t\treturn false;\r\n\r\n\t// Try setting the prop to see if it creates an attribute.\r\n\tel[name] = 1;\r\n\tvar isAttr = el.hasAttribute(name);\r\n\tdelete el[name];\r\n\treturn isAttr;\r\n};\r\n\r\n/**\r\n * Find object values by keys that start with prefix.\r\n * @param obj {object}\r\n * @param prefix {string}\r\n * @returns {boolean} */\r\nvar hasKeyStartingWith = (obj, prefix) => {\r\n\tfor (let key in obj)\r\n\t\tif (key.startsWith(prefix))\r\n\t\t\treturn true;\r\n\treturn false;\r\n};\r\n\r\n/**\r\n * @param el {HTMLElement}\r\n * @returns {int} */\r\n//var parentIndex = (el) => !el.parentNode ? 0 : Array.prototype.indexOf.call(el.parentNode.children, el);\r\n\r\n/**\r\n * @param obj {object}\r\n * @param path {string[]}\r\n * @param create {boolean=false} Create the path if it doesn't exist.\r\n * @param value {*=} If not undefined, set the object's path field to this value.\r\n * @param watchless {boolean=false} If true, the value will be set without triggering any watch notifications. */\r\nvar traversePath = (obj, path, create, value, watchless) => {\r\n\tif (!obj && !create && path.length)\r\n\t\treturn undefined;\r\n\r\n\tlet i = 0;\r\n\tfor (let srcProp of path) {\r\n\t\tlet last = i === path.length-1;\r\n\r\n\t\t// If the path is undefined and we're not to the end yet:\r\n\t\tif (obj[srcProp] === undefined) {\r\n\r\n\t\t\t// If the next index is an integer or integer string.\r\n\t\t\tif (create) {\r\n\r\n\t\t\t\tif (!last) {\r\n\t\t\t\t\t// If next level path is a number, create as an array\r\n\t\t\t\t\tif ((path[i + 1] + '').match(/^\\d+$/))\r\n\t\t\t\t\t\tobj[srcProp] = [];\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tobj[srcProp] = {};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\treturn undefined; // can't traverse\r\n\t\t}\r\n\r\n\t\t// If last item in path\r\n\t\tif (last && value !== undefined) {\r\n\t\t\tif (watchless) {\r\n\t\t\t\tobj = obj.$removeProxy || obj;\r\n\t\t\t\tobj.$disableWatch = true; // sometimes this causes stack overflow?  Perhaps I need to use Object.getOwnPropertyDescriptor() to see if it's a prop?\r\n\t\t\t}\r\n\r\n\t\t\tobj[srcProp] = value;\r\n\t\t\tif (watchless)\r\n\t\t\t\tdelete obj.$disableWatch;\r\n\t\t}\r\n\r\n\t\t// Traverse deeper along destination object.\r\n\t\tobj = obj[srcProp];\r\n\t\ti++;\r\n\t}\r\n\r\n\treturn obj;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Operates recursively to remove all proxies.\r\n * TODO: This is used by watchproxy and should be moved there?\r\n * @param obj {*}\r\n * @param visited {WeakSet=} Used internally.\r\n * @returns {*} */\r\nvar removeProxies = (obj, visited) => {\r\n\tif (obj === null || obj === undefined)\r\n\t\treturn obj;\r\n\r\n\tif (obj.$isProxy) {\r\n\t\tobj = obj.$removeProxy;\r\n\r\n\t\t//#IFDEV\r\n\t\tif (obj.$isProxy) // If still a proxy.  There should never be more than 1 level deep of proxies.\r\n\t\t\tthrow new XElementError(\"Double wrapped proxy found.\");\r\n\t\t//#ENDIF\r\n\t}\r\n\r\n\tif (typeof obj === 'object') {\r\n\t\tif (!visited)\r\n\t\t\tvisited = new WeakSet();\r\n\t\telse if (visited.has(obj))\r\n\t\t\treturn obj; // visited this object before in a cyclic data structure.\r\n\t\tvisited.add(obj);\r\n\r\n\t\t// Recursively remove proxies from every property of obj:\r\n\t\tfor (let name in Object.keys(obj)) { // Don't mess with inherited properties.  E.g. defining a new outerHTML.\r\n\t\t\tlet t = obj[name];\r\n\t\t\tlet v = removeProxies(t, visited);\r\n\r\n\t\t\t// If a proxy was removed from something created with Object.defineOwnProperty()\r\n\t\t\tif (v !== t) {\r\n\t\t\t\tif (Object.getOwnPropertyDescriptor(obj, name).writable) // we never set writable=true when we defineProperty.\r\n\t\t\t\t\tobj[name] = v;\r\n\t\t\t\telse {\r\n\t\t\t\t\t// It's a defined property.  Set it on the underlying object.\r\n\t\t\t\t\tlet wp = watch.objects.get(obj);\r\n\t\t\t\t\tlet node = wp ? wp.fields_ : obj;\r\n\t\t\t\t\tnode[name] = v\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn obj;\r\n};\r\nexport { arrayEq, hasKeys, csv, isObj, isValidAttribute, hasKeyStartingWith, traversePath, eventNamesMap, XElementError };\r\nexport {removeProxy, removeProxies};","// Regex for matching javascript variables.  Made from pieces of this regex:  https://www.regexpal.com/?fam=112426\r\nvar identifier = '([$a-z_][$a-z0-9_]*)';       // A regular variable name.\r\nvar dotIdentifier = '\\\\.\\\\s*' + identifier;\r\nvar varBrD = '\\\\[\\\\s*\"(([^\"]|\\\\\")*)\"\\\\s*]';  // A [\"as\\\"df\"] index\r\nvar varBrS = varBrD.replace(/\"/g, \"'\");      // A ['as\\'df'] index\r\nvar varNum = \"\\\\[\\\\s*(\\\\d+)\\\\s*]\";           // A [3] index (numerical)\r\n\r\nvar or = '\\\\s*|\\\\s*';\r\nvar varProp = dotIdentifier + or + varBrD + or + varBrS + or + varNum;\r\n\r\nvar or2 = '\\\\s*\\\\(?|^\\\\s*';\r\nvar varPropOrFunc = '^\\\\s*' + dotIdentifier + or2 + varBrD + or2 + varBrS + or2 + varNum + '\\\\s*\\\\(?';\r\n\r\nvar isStandaloneVarRegex = new RegExp('^' + identifier + '(' + varProp + ')*$', 'i');\r\nvar isSimpleCallRegex = new RegExp('^' + identifier + '(' + varProp + ')*\\\\(', 'i');\r\nvar varStartRegex = new RegExp(identifier + '\\\\s*\\\\(?', 'gi');\r\nvar varPropRegex  = new RegExp(varPropOrFunc, 'gi');\r\n\r\n// https://mathiasbynens.be/notes/javascript-identifiers\r\n// We exclude 'let,package,interface,implements,private,protected,public,static,yield' because testing shows Chrome accepts these as valid var names.\r\nvar nonVars = 'length,NaN,Infinity,caller,callee,prototype,arguments,true,false,null,undefined,break,case,catch,continue,debugger,default,delete,do,else,finally,for,function,if,in,instanceof,new,return,switch,throw,try,typeof,var,void,while,with,class,const,enum,export,extends,import,super'.split(/,/g);\r\nvar nonVars2 = 'super,NaN,Infinity,true,false,null,undefined'.split(/,/g); // Don't add \"this.\" prefix to thse automatically.\r\n\r\n/**\r\n * A stanalone var can automatically have \"this.\" prepended to it.\r\n * @param {string} code\r\n * @returns {boolean} */\r\nvar isStandaloneVar = (code) => {\r\n\treturn !nonVars2.includes(code) && !!code.trim().match(isStandaloneVarRegex);\r\n};\r\nvar isStandaloneCall = (code) => {\r\n\t// if it starts with a variable followed by ( and has no more than one semicolon.\r\n\tcode = code.trim();\r\n\r\n\t// If there's a semicolon other than at the end.\r\n\t// TODO: This doesn't account for if there's a semicolon in a string argument to the function.\r\n\tvar semi = code.indexOf(';');\r\n\tif (semi !== -1 && semi !== code.length-1)\r\n\t\treturn false;\r\n\r\n\treturn !nonVars2.includes(code) && !!code.match(isSimpleCallRegex);\r\n};\r\n\r\n/**\r\n * Take a string of code and parse out all JavaScript variable names,\r\n * ignoring function calls \"name(\" and anything in nonVars that's not inside [''].\r\n * @param code {string}\r\n * @param includeThis {boolean=false} Include \"this.\" when parsing variables.\r\n * @param allowCall {boolean=false}\r\n * @returns {string[][]} An array of paths, where a path is all sub-properties of a variable name.\r\n * @example\r\n *     parseVars('this.person.firstName.substr()', true) // returns [['this', 'person', 'firstName']]\r\n *     parseVars('var a = b[\"c\"]') // returns [['a'], ['b', 'c']] */\r\nvar parseVars = (code, includeThis, allowCall) => {\r\n\t//code = code.trim(); // Breaks indices.\r\n\tvar result = [];\r\n\tvar index = 0;\r\n\r\n\twhile (code.length) {\r\n\t\tvar item = undefined;\r\n\t\tlet regex = varStartRegex; // Reset for looking for start of a variable.\r\n\t\tlet keepGoing = 1;\r\n\t\tlet currentVar = [], matches;\r\n\t\tcurrentVar.index_ = []; // track the index of each match within code.\r\n\t\twhile (keepGoing && code.length && !!(matches = regex.exec(code))) {\r\n\r\n\t\t\t// Add the start of the match.\r\n\t\t\tindex += matches.index;\r\n\r\n\r\n\t\t\tcode = code.slice(regex.lastIndex); // advance forward in parsing code.\r\n\t\t\tregex.lastIndex = 0; // reset the regex.\r\n\r\n\t\t\t// Don't grab functions or common functions properties as vars unless they are within brackets.\r\n\t\t\t// matches[1] is the match for a .variable and not something in brackets.\r\n\t\t\t// TODO: allow some nonvars if in brackets?\r\n\t\t\tkeepGoing = (allowCall || !matches[0].endsWith('(')) && !nonVars.includes(matches[1]);\r\n\t\t\tif (keepGoing) {\r\n\r\n\t\t\t\t// fitler() removes undefineds from matches.\r\n\t\t\t\t// This lets us get the first non-undefiend parenthetical submatch.\r\n\t\t\t\titem = matches.filter(Boolean)[1];\r\n\r\n\t\t\t\t// Add varible property to current path\r\n\t\t\t\tif (includeThis || item !== 'this') {\r\n\t\t\t\t\tcurrentVar.push(item);\r\n\t\t\t\t\tcurrentVar.index_.push({\r\n\t\t\t\t\t\tstart: index,\r\n\t\t\t\t\t\tend: index+item.length\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tregex = varPropRegex; // switch to reading subsequent parts of the variable.\r\n\t\t\t}\r\n\r\n\t\t\t// Add the length of the match.\r\n\t\t\tindex += matches[0].length;\r\n\t\t}\r\n\r\n\t\t// Start parsing a new variable.\r\n\t\tindex += regex.lastIndex;\r\n\t\tregex.lastIndex = 0; // reset the regex.\r\n\t\tif (currentVar.length)\r\n\t\t\tresult.push(currentVar);\r\n\t\telse if (!matches /*item !== 'this'*/) // if we found nothing, stop entirely.\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn result;\r\n};\r\n\r\n// TODO: actual parsing.\r\nvar trimThis = function(code) {\r\n\treturn code.replace(/^this\\./, '');\r\n};\r\n\r\n/**\r\n * TODO: this function should leave alone anything after a :\r\n *\r\n * If a replacement value is \"this\", it'll be trimmed off the beginning.\r\n * @param code {string}\r\n * @param replacements {object<string, string>}\r\n * @returns {string} */\r\nvar replaceVars = (code, replacements) => {\r\n\tif (!Array.isArray(replacements))\r\n\t\treplacements = [replacements];\r\n\r\n\tfor (let replacement of replacements)\r\n\t\tfor (let oldVar in replacement) {\r\n\t\t\tvar paths = parseVars(code, 1);\r\n\t\t\tfor (let path of paths.reverse()) { // We loop in reverse so the replacement indices don't get messed up.\r\n\r\n\t\t\t\tif (path.length >= 1 && path[0] === oldVar) {\r\n\t\t\t\t\tlet newVal = replacement[oldVar];\r\n\t\t\t\t\tif (newVal === 'this')\r\n\t\t\t\t\t\tcode = path[1] + (path.length > 2 ? code.slice(path.index_[2].start) : '');\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcode = code.slice(0, path.index_[0].start) + replacement[oldVar] + code.slice(path.index_[0].end);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\treturn code;\r\n};\r\n\r\n/**\r\n * TODO: Could this be replaced with:\r\n * result = eval('{' + code + '}');\r\n * No, because sometimes the value needs this. prepended.  Or the properties are undefined.\r\n *\r\n * TODO: This will fail if code has \";\" inside strings.\r\n * each key is in the format name: expr\r\n * @param code\r\n * @returns {object<string, string>} */\r\nvar parseObj = (code) => {\r\n\t//return eval('{' + code + '}');\r\n\r\n\tlet result = {};\r\n\tlet pieces = code.split(/\\s*;\\s*/); // splitting on comma will divide objects.  TODO, need to support a real parser.  JSON won't understand var names.  eval() will evaluate them.\r\n\tfor (let piece of pieces) {\r\n\t\tvar colon = piece.indexOf(':');\r\n\t\tlet value =  piece.slice(colon+1).trim();\r\n\t\tif (value) {\r\n\t\t\tlet key = piece.slice(0, colon).trim();\r\n\t\t\tresult[key] = value;\r\n\t\t}\r\n\r\n\t\t//let [key, value] = piece.split(/\\s*:\\s*/); // this splits more than once.\r\n\t\t//result[key] = value;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n/*\r\nvar joinObj = (obj) => {\r\n\tvar result = [];\r\n\tfor (let name in obj)\r\n\t\tresult.push (name + ':' + obj[name]);\r\n\treturn result.join(';');\r\n};\r\n*/\r\n\r\n/**\r\n * Parse \"items : item\" into two part, always splitting on the last colon.\r\n * @param code {string}\r\n * @return {[string, string, string]} foreachCode, loopVar, indexVar (optional) */\r\nvar parseLoop = (code) => {\r\n\tvar result = code.split(/[,:](?=[^:]+$)/).map((x)=>x.trim()); // split on comma and colon only if there's no subsequent colons.\r\n\tif (result[2])\r\n\t\tresult = [result[0], result[2], result[1]]; // swap elements 1 and 2, so indexVar is last.\r\n\r\n\t//#IFDEV\r\n\tif (!isStandaloneVar(result[1]))\r\n\t\tthrow new XElementError('Could not parse loop variable in data-loop attribute \"' + code + '\".');\r\n\tif (result[2] && !isStandaloneVar(result[2]))\r\n\t\tthrow new XElementError('Invalid index variable in data-loop attribute \"' + code + '\".');\r\n\tif (result.length > 3)\r\n\t\tthrow new XElementError('Could not parse data-loop attribute \"' + code + '\".');\r\n\t//#ENDIF\r\n\r\n\treturn result;\r\n\r\n\t/*\r\n\t// Parse code into foreach parts.\r\n\tvar colon = code.lastIndexOf(':');\r\n\tif (colon < 0) // -1\r\n\t\tthrow new XElementError('data-loop attribute \"' + code + '\" missing colon.');\r\n\tvar result = [code.slice(0, colon)];       // foreach part\r\n\tvar loopVar = code.slice(colon+1).trim(); // loop var\r\n\tvar comma = loopVar.indexOf(',');\r\n\tif (comma >= 0) { // If index.\r\n\t\tresult.push(loopVar.slice(0, comma).trim());\r\n\t\tresult.push((loopVar.slice(comma+1).trim()));\r\n\t}\r\n\telse\r\n\t\tresult.push(loopVar)\r\n\r\n\treturn result;\r\n\t*/\r\n};\r\n\r\n/**\r\n * Add a \"this.\" prefix to code where we can.\r\n * TODO: This only works for standalone variables.\r\n * @param code  {string}\r\n * @param context {object<string, string>}\r\n * @param isStandalone {function(string):boolean=} A function to detect whether the code is a stanadlone var.\r\n * @param prefix {string=} Defaults to \"this\"\r\n * @returns {string} */\r\nvar addThis = (code, context, isStandalone, prefix) => {\r\n\tif (Array.isArray(context))\r\n\t\tcontext = context[0]; // TODO: Instead of this hack, we need to handle context as an array.\r\n\r\n\tprefix = prefix || 'this';\r\n\tisStandalone = isStandalone || isStandaloneVar;\r\n\tif (!isStandalone(code))\r\n\t\treturn code;\r\n\r\n\t// If it starts with this or an item in context, do nothing.\r\n\tcode = code.trim();\r\n\tlet contextVars = Object.keys(context || {});\r\n\tfor (let pre of [prefix, ...contextVars])\r\n\t\tif (code.match(new RegExp('^' + pre + '(\\s*[\\.[]|$)'))) // starts with \"prefix.\" or \"prefix[\"\r\n\t\t\treturn code;\r\n\r\n\treturn prefix + '.' + code;\r\n};\r\n\r\n// Exports\r\nwindow.parseLoop = parseLoop; // temporary for EditableSelect.\r\n\r\nexport { isStandaloneVar, isStandaloneCall, parseVars, trimThis, replaceVars, parseObj, parseLoop, addThis };","import { removeProxies, isObj, removeProxy } from './utils.js';\r\n\r\n/**\r\n * @property object.$isProxy\r\n * @property object.$removeProxy\r\n * @property object.$trigger\r\n * */\r\n\r\nvar arrayRead = ['indexOf', 'lastIndexOf', 'includes'];\r\nvar arrayWrite = ['push', 'pop', 'splice', 'shift', 'sort', 'reverse', 'unshift'];\r\n\r\n/**\r\n * Handler object used when calling WatchUtil.getProxy() */\r\nvar handler = {\r\n\t/**\r\n\t * Overridden to wrap returned values in a Proxy, so we can see when they're changed.\r\n\t * And to keep track of the path as we traverse deeper into an object.\r\n\t * @param obj {Array|object}\r\n\t * @param field {string} An object key or array index.\r\n\t * @returns {*} */\r\n\tget(obj, field) {\r\n\r\n\t\t// Special properties\r\n\t\tif (field[0] === '$') {\r\n\t\t\tif (field === '$removeProxy') // most common paths first.\r\n\t\t\t\treturn obj;\r\n\t\t\tif (field === '$isProxy')\r\n\t\t\t\treturn true;\r\n\t\t\tif (field === '$trigger') {\r\n\t\t\t\treturn (path) => {\r\n\t\t\t\t\tlet roots = WatchUtil.getRoots(obj);\r\n\t\t\t\t\tfor (let root of roots)\r\n\t\t\t\t\t\tWatchUtil.notifyCallbacks(root, 'set', path || [], obj);\r\n\t\t\t\t\t//root.notify_('set', path || [], obj);\r\n\t\t\t\t\treturn roots;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Debugging functions\r\n\t\t\tif (field === '$roots')\r\n\t\t\t\treturn WatchUtil.getRoots(obj);\r\n\t\t\tif (field === '$subscribers') {\r\n\t\t\t\treturn Array.from(WatchUtil.getRoots(obj))\r\n\t\t\t\t\t.map((x) => x.callbacks_)\r\n\t\t\t\t\t.reduce((a, b) => [...a, ...b])\r\n\t\t\t\t\t.map((x) => x('info'))\r\n\t\t\t\t\t.reduce((a, b) => [...a, ...b])\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tlet result = obj[field];\r\n\r\n\r\n\t\t// Return the underlying array's iterator, to make for(...of) loops work.\r\n\t\tif (field === Symbol.iterator)\r\n\t\t\treturn result;\r\n\r\n\t\t// Make sure to call functions on the unproxied version\r\n\t\tif (typeof result === 'function') {\r\n\t\t\tlet obj2 = obj.$removeProxy || obj;\r\n\t\t\treturn obj2[field].bind(obj2);\r\n\t\t}\r\n\r\n\t\t// We only wrap objects and arrays in proxies.\r\n\t\t// Primitives and functions we leave alone.\r\n\t\t// if (result && typeof result === 'object' && !(result instanceof Node)) {\r\n\t\tif (result && typeof result === 'object') { // isObj() inline to hopefully be faster.\r\n\r\n\t\t\t// Remove any proxies.\r\n\t\t\tresult = result.$removeProxy || result;\r\n\t\t\t//#IFDEV\r\n\t\t\tif (result.$isProxy)\r\n\t\t\t\tthrow new XElementError(\"Double wrapped proxy found.\");\r\n\t\t\t//#ENDIF\r\n\r\n\t\t\t// Make sure the path from the root to the object's field is tracked:\r\n\t\t\tlet roots = WatchUtil.getRoots(obj);\r\n\t\t\tfor (let root of roots) { // Get all paths from the roots to the parent.\r\n\t\t\t\tlet parentPaths = WatchUtil.getPaths(root, obj);\r\n\t\t\t\tfor (let parentPath of parentPaths) {\r\n\r\n\t\t\t\t\t// Combine each path with the field name.\r\n\t\t\t\t\tWatchUtil.addPath(root, [...parentPath, field], result); // Add to our list of tracked paths.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn WatchUtil.getProxy(result);\r\n\t\t}\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Trap called whenever anything in an array or object is set.\r\n\t * Changing and shifting array values will also call this function.\r\n\t * @param obj {Array|object} root or an object within root that we're setting a property on.\r\n\t * @param field {string} An object key or array index.\r\n\t * @param newVal {*}\r\n\t * @returns {boolean} */\r\n\tset(obj, field, newVal) {\r\n\t\tnewVal = removeProxies(newVal);\r\n\r\n\t\t// Don't allow setting proxies on underlying obj.\r\n\t\t// This removes them recursivly in case of something like newVal=[Proxy(obj)].\r\n\t\tlet oldVal = obj[field];\r\n\r\n\t\t// Set the value.\r\n\t\t// TODO: This can trigger notification if field was created on obj by defineOwnProperty()!\r\n\t\t// Should I use .$disableWatch?\r\n\t\tobj[field] = newVal;\r\n\r\n\r\n\t\tlet roots = WatchUtil.getRoots(obj);\r\n\t\tfor (let root of roots) { // Notify\r\n\t\t\tlet parentPaths = WatchUtil.getPaths(root, obj);\r\n\t\t\tfor (let parentPath of parentPaths) {\r\n\t\t\t\tlet path = [...parentPath, field];\r\n\t\t\t\tWatchUtil.notifyCallbacks(root, 'set', path, newVal, oldVal);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn 1; // Proxy requires us to return true.\r\n\t},\r\n\r\n\t/**\r\n\t * Trap called whenever anything in an array or object is deleted.\r\n\t * @param obj {Array|object} root or an object within root that we're deleting a property on.\r\n\t * @param field {int|string} An object key or array index.\r\n\t * @returns {boolean} */\r\n\tdeleteProperty(obj, field) {\r\n\t\tif (Array.isArray(obj))\r\n\t\t\tobj.splice(field, 1);\r\n\t\telse\r\n\t\t\tdelete obj[field];\r\n\r\n\t\tlet roots = WatchUtil.getRoots(obj);\r\n\t\tfor (let root of roots) {\r\n\t\t\tlet parentPaths = WatchUtil.getPaths(root, obj);\r\n\t\t\tfor (let parentPath of parentPaths) {\r\n\t\t\t\tlet path = [...parentPath, field];\r\n\t\t\t\tWatchUtil.notifyCallbacks(root, 'set', path);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn 1; // Proxy requires us to return true.\r\n\t}\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar WatchUtil = {\r\n\r\n\t/**\r\n\t * Get or create proxy for an object.\r\n\t * An object will never have more than one proxy.\r\n\t * @returns {Proxy} */\r\n\tgetProxy: function(obj) {\r\n\t\tlet proxy = WatchUtil.proxies.get(obj);\r\n\t\tif (!proxy) {\r\n\t\t\tWatchUtil.proxies.set(obj, proxy = new Proxy(obj, handler));\r\n\r\n\t\t\tif (Array.isArray(obj)) {\r\n\r\n\t\t\t\t// Because this.proxy_ is a Proxy, we have to replace the functions\r\n\t\t\t\t// on it in this special way by using Object.defineProperty()\r\n\t\t\t\t// Directly assigning this.proxy_.indexOf = ... calls the setter and leads to infinite recursion.\r\n\t\t\t\tfor (let func of arrayRead) // TODO: Support more array functions.\r\n\r\n\t\t\t\t\tObject.defineProperty(proxy, func, {\r\n\t\t\t\t\t\tenumerable: false,\r\n\t\t\t\t\t\tget: () => // Return a new version of indexOf or the other functions.\r\n\t\t\t\t\t\t\t(item) => Array.prototype[func].call(obj, removeProxy(item))\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * Intercept array modification functions so that we only send one nofication instead\r\n\t\t\t\t * of a notification every time an array item is moved (shift, unshift, splice) or the length changes. */\r\n\t\t\t\tfor (let func of arrayWrite)\r\n\t\t\t\t\tObject.defineProperty(proxy, func, {\r\n\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\tenumerable: false,\r\n\t\t\t\t\t\tget: () =>\r\n\r\n\t\t\t\t\t\t\t// Return a new version of push or the other functions.\r\n\t\t\t\t\t\t\tfunction () {\r\n\r\n\t\t\t\t\t\t\t\tlet originalLength = obj.length;\r\n\t\t\t\t\t\t\t\tvar startIndex = 0;\r\n\t\t\t\t\t\t\t\tif (func === 'push')\r\n\t\t\t\t\t\t\t\t\tstartIndex = originalLength;\r\n\t\t\t\t\t\t\t\telse if (func === 'pop')\r\n\t\t\t\t\t\t\t\t\tstartIndex = originalLength - 1;\r\n\t\t\t\t\t\t\t\telse if (func === 'splice')\r\n\t\t\t\t\t\t\t\t\tstartIndex = arguments[0] < 0 ? originalLength - arguments[0] : arguments[0];\r\n\r\n\r\n\t\t\t\t\t\t\t\t// Apply array operations on the underlying watched object, so we don't notify a jillion times.\r\n\t\t\t\t\t\t\t\tlet result = Array.prototype[func].apply(obj, arguments);\r\n\r\n\t\t\t\t\t\t\t\t// Rebuild the array indices inside the proxy objects.\r\n\t\t\t\t\t\t\t\t// This is covered by the test Watch.arrayShift2()\r\n\t\t\t\t\t\t\t\t// TODO: This can be faster if we only update the affected array elements.\r\n\t\t\t\t\t\t\t\tif (['splice', 'shift', 'sort', 'reverse', 'unshift'].includes(func)) { // ops that modify within the array.\r\n\t\t\t\t\t\t\t\t\tWatchUtil.rebuildArray(obj, startIndex, null, null);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Trigger a notification for every array element changed, instead of one for eavery sub-operation.\r\n\t\t\t\t\t\t\t\t// Commented out because it messes up xloops.\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\t\t\t\tlet roots = WatchUtil.getRoots(obj);\r\n\t\t\t\t\t\t\t\tfor (let root of roots) {\r\n\t\t\t\t\t\t\t\t\tlet parentPaths = WatchUtil.getPaths(root, obj);\r\n\t\t\t\t\t\t\t\t\tfor (let parentPath of parentPaths) {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = startIndex; i < proxy.length; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tWatchUtil.notifyCallbacks(root, 'set', [...parentPath, i + ''], obj[i]);\r\n\t\t\t\t\t\t\t\t\t\tfor (i; i<originalLength; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tWatchUtil.notifyCallbacks(root, 'delete', [...parentPath, i + '']);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Old version that notifies for the whole array instead of only the items changed:\r\n\t\t\t\t\t\t\t\t//proxy.$trigger();\r\n\r\n\t\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn proxy;\r\n\t},\r\n\r\n\t/**\r\n\t * For item, find all proxyRoots and update their paths such that they end with path.\r\n\t * Then we recurse and do the same for the children, appending to path as we go.\r\n\t * Ths effectively lets us update the path of all of item's subscribers.\r\n\t * This is necessary for example when an array is spliced and the paths after the splice need to be updated.\r\n\t * @param obj {object|*[]}\r\n\t * @param startIndex {int?} If set, only rebuild array elements at and after this index.\r\n\t * @param path {string[]=}\r\n\t * @param visited {WeakSet=} */\r\n\trebuildArray: function(obj, startIndex, path, visited) {\r\n\t\tpath = path || [];\r\n\t\tvisited = visited || new WeakSet();\r\n\t\tif (startIndex === undefined)\r\n\t\t\tstartIndex = 0;\r\n\r\n\t\tif (visited.has(obj))\r\n\t\t\treturn;\r\n\t\tvisited.add(obj);\r\n\r\n\t\tif (path.length) {\r\n\r\n\t\t\tlet roots = WatchUtil.roots.get(obj);\r\n\t\t\tif (!roots) // because nothing is watching this array element.\r\n\t\t\t\treturn;\r\n\r\n\t\t\tfor (let root of roots) {\r\n\t\t\t\tlet parentPaths = WatchUtil.getPaths(root, obj);\r\n\t\t\t\tfor (let i in parentPaths) {\r\n\t\t\t\t\tlet oldPath = parentPaths[i];\r\n\r\n\t\t\t\t\t// Swap end of oldPath with the new path if the new path  points from root to obj.\r\n\t\t\t\t\tlet start = oldPath.length - path.length;\r\n\t\t\t\t\tif (start >= 0) {\r\n\r\n\t\t\t\t\t\t// Create the newPath.\r\n\t\t\t\t\t\tlet newPath = oldPath.slice();\r\n\t\t\t\t\t\tfor (let j = start; j < oldPath.length; j++)\r\n\t\t\t\t\t\t\tnewPath[j] = path[j - start];\r\n\r\n\r\n\t\t\t\t\t\t// See if newPath is a valid path from root to obj.\r\n\t\t\t\t\t\tlet item = root;\r\n\t\t\t\t\t\tfor (let field of newPath) {\r\n\t\t\t\t\t\t\titem = item[field];\r\n\t\t\t\t\t\t\tif (!item)\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Update the path.\r\n\t\t\t\t\t\tif (item === obj)\r\n\t\t\t\t\t\t\tparentPaths[i] = newPath;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// Recurse through children to update their paths too.\r\n\t\t// This is testesd by the arrayShiftRecurse() test.\r\n\t\tif (Array.isArray(obj))\r\n\t\t\tfor (let i=startIndex; i<obj.length; i++) {\r\n\t\t\t\tif (Array.isArray(obj[i]) || isObj(obj[i]))\r\n\t\t\t\t\tWatchUtil.rebuildArray(obj[i], 0, [...path, i+''], visited);\r\n\t\t\t}\r\n\t\telse if (isObj(obj))\r\n\t\t\tfor (let i in obj)\r\n\t\t\t\tif (Array.isArray(obj[i]) || isObj(obj[i]))\r\n\t\t\t\t\tWatchUtil.rebuildArray(obj[i], 0, [...path, i+''], visited);\r\n\t},\r\n\r\n\t/**\r\n\t * Get all roots that have paths to obj.\r\n\t * @param obj\r\n\t * @returns {Set.<Object>|Array} An iterable list. */\r\n\tgetRoots: function(obj)\t{\r\n\t\tobj = obj.$removeProxy || obj;\r\n\t\treturn WatchUtil.roots.get(obj) || [];\r\n\t},\r\n\r\n\t/**\r\n\t * Register a path from root to obj. */\r\n\taddPath: function(root, newPath, obj) {\r\n\t\tobj = obj.$removeProxy || obj;\r\n\t\troot = root.$removeProxy || root;\r\n\r\n\t\t// Add root from obj to path.\r\n\t\tlet a = WatchUtil.roots.get(obj);\r\n\t\tif (!a)\r\n\t\t\tWatchUtil.roots.set(obj, a = new Set());\r\n\t\ta.add(root);\r\n\r\n\t\t// Get the map from object to paths.\r\n\t\tlet objMap = WatchUtil.paths.get(root);\r\n\t\tif (!objMap)\r\n\t\t\tWatchUtil.paths.set(root, objMap=new WeakMap());\r\n\r\n\t\t// Get the paths\r\n\t\tlet paths = objMap.get(obj);\r\n\t\tif (!paths)\r\n\t\t\tobjMap.set(obj, [newPath]);\r\n\r\n\t\t// Add the path if it isn't already registered.\r\n\t\t// TODO: This could possibly be faster if the javascript Set could index by arrays.\r\n\t\telse {\r\n\t\t\tfor (let existingPath of paths) {\r\n\r\n\t\t\t\tvar l = existingPath.length;\r\n\t\t\t\tif (newPath.length < existingPath.length)\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t// If the new path begins with existingPath, don't add it.\r\n\t\t\t\t// Because now we're just expanding more paths from circular references.\r\n\t\t\t\t// Inline version of arrayEq() because it's faster.\r\n\t\t\t\tvar same = true;\r\n\t\t\t\tfor (let i=0; i<l; i++)\r\n\t\t\t\t\tif (same = !(existingPath[i] !== newPath[i]))\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\tif (same)\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tpaths.push(newPath);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get all paths from root to obj. */\r\n\tgetPaths: function(root, obj) {\r\n\r\n\t\t//#IFDEV\r\n\t\tif (root.$isProxy)\r\n\t\t\tthrow new Error(\"Can't be proxy.\");\r\n\t\t//#ENDIF\r\n\t\t\t\r\n\t\t// Get the map from object to paths.\r\n\t\tlet objMap = WatchUtil.paths.get(root);\r\n\t\tif (!objMap)\r\n\t\t\treturn [];\r\n\r\n\t\t// Get the paths\r\n\t\treturn objMap.get(obj.$removeProxy || obj) || [];\r\n\t},\r\n\r\n\r\n\taddCallback: function(root, callback) {\r\n\t\troot = root.$removeProxy || root;\r\n\r\n\t\tlet callbacks = WatchUtil.callbacks.get(root);\r\n\t\tif (!callbacks)\r\n\t\t\tWatchUtil.callbacks.set(root, callbacks=[]);\r\n\t\tcallbacks.push(callback);\r\n\t},\r\n\r\n\tgetCallbacks: function(root) {\r\n\t\troot = root.$removeProxy || root;\r\n\t\treturn WatchUtil.callbacks.get(root) || [];\r\n\t},\r\n\r\n\tnotifyCallbacks: function(root, action, path, newVal, oldVal) {\r\n\t\tlet callbacks = WatchUtil.getCallbacks(root);\r\n\t\tfor (let callback of callbacks)\r\n\t\t\tcallback(action, path, newVal, oldVal);\r\n\t},\r\n\r\n\tcleanup: () => {\r\n\t\tWatchUtil.proxies = new WeakMap();\r\n\t\tWatchUtil.roots = new WeakMap();\r\n\t\tWatchUtil.callbacks = new WeakMap();\r\n\t\tWatchUtil.paths = new WeakMap();\r\n\t}\r\n};\r\n\r\n/** @type {WeakMap<object, Proxy>} Map from an object to the Proxy of itself. */\r\nWatchUtil.proxies = new WeakMap();\r\n\r\n/** @type {WeakMap<object, Set<object>>} A map from an object to all of its root objects. */\r\nWatchUtil.roots = new WeakMap();\r\n\r\n\r\n/** @type {WeakMap<object, function[]>} A map from roots to the callbacks that should be called when they're changed.. */\r\nWatchUtil.callbacks = new WeakMap();\r\n\r\n/**\r\n * A map of all paths from a root to an object.\r\n * Outer weakmap is indexed by root, inner by object.\r\n * @type {WeakMap<object, WeakMap<object, string[][]>>} */\r\nWatchUtil.paths = new WeakMap();\r\n\r\n\r\n\r\n/**\r\n * Create a copy of root, where callback() is called whenever anything within object is added, removed, or modified.\r\n * Monitors all deeply nested properties including array operations.\r\n * Watches will not extend into HTML elements and nodes.\r\n * Inspired by: stackoverflow.com/q/41299642\r\n * @param root {object}\r\n * @param callback {function(action:string, path:string[], value:string?)} Action is 'set' or 'delete'.\r\n * @returns {Proxy} */\r\nvar watchProxy = (root, callback) => {\r\n\t//#IFDEV\r\n\tif (!isObj(root))\r\n\t\tthrow new XElementError('Can only watch objects');\r\n\t//#ENDIF\r\n\r\n\t// Add a path from root to itself, so that when we call WatchUtil.getRoots() on a root, we get an empty path.\r\n\tWatchUtil.addPath(root, [], root);\r\n\r\n\tWatchUtil.addCallback(root, callback);\r\n\treturn WatchUtil.getProxy(root);\r\n};\r\n\r\nexport { watchProxy, WatchUtil };","import {csv, hasKeyStartingWith, removeProxy, traversePath, XElementError} from '../src/utils.js';\r\nimport { watchProxy } from './watchProxy.js';\r\n\r\n/**\r\n * Allow subcribing only to specific properties of an object.\r\n * Internally, the property is replaced with a call to Object.defineProperty() that forwards to\r\n * a proxy created by watchObh() above. */\r\nclass WatchProperties {\r\n\r\n\tconstructor(obj) {\r\n\t\tthis.obj_ = obj;   // Original object being watched.\r\n\t\tthis.fields_ = {}; // $removeProxy underlying fields that store the data.\r\n\t\t                   // This is necessary to store the values of obj_ after defineProperty() is called.\r\n\t\tthis.proxy_ = watchProxy(this.fields_, this.notify_.bind(this));\r\n\r\n\t\t/** @type {object<string, function>} A map from a path to the callback subscribed to that path. */\r\n\t\tthis.subs_ = {};\r\n\t}\r\n\r\n\t/**\r\n\t * When a property or sub-property changes, notify its subscribers.\r\n\t * This is an expanded version of watchproxy.notify.  It also notifies every callback subscribed to a parent of path,\r\n\t * and all children of path if their own value changed.\r\n\t * @param action {string}\r\n\t * @param path {string[]}\r\n\t * @param value {*=}\r\n\t * @param oldVal {*=} */\r\n\tnotify_(action, path, value, oldVal) {\r\n\r\n\t\tif (action === 'info')\r\n\t\t\treturn this.subs_;\r\n\r\n\t\tlet cpath = csv(path);\r\n\r\n\t\t// Traverse up the path looking for anything subscribed.\r\n\t\tlet parentPath = path.slice(0, -1);\r\n\t\twhile (parentPath.length) {\r\n\t\t\tlet parentCPath = csv(parentPath); // TODO: This seems like a lot of work for any time a property is changed.\r\n\r\n\t\t\tif (parentCPath in this.subs_)\r\n\t\t\t\t/** @type function */\r\n\t\t\t\tfor (let callback of this.subs_[parentCPath])\r\n\t\t\t\t\t// \"this.obj_\" so it has the context of the original object.\r\n\t\t\t\t\t// We set indirect to true, which data-loop's rebuildChildren() uses to know it doesn't need to do anything.\r\n\t\t\t\t\tcallback.apply(this.obj_, arguments)\r\n\t\t\tparentPath.pop();\r\n\t\t}\r\n\r\n\t\t// Notify at the current level:\r\n\t\tif (cpath in this.subs_)\r\n\t\t\tfor (let callback of this.subs_[cpath])\r\n\t\t\t\tcallback.apply(this.obj_, arguments);\r\n\r\n\t\t// Traverse to our current level and downward looking for anything subscribed\r\n\t\tlet newVal = traversePath(this.obj_, path);\r\n\t\tfor (let name in this.subs_)\r\n\t\t\tif (name.startsWith(cpath) && name.length > cpath.length) {\r\n\t\t\t\tlet subPath = name.slice(cpath.length > 0 ? cpath.length + 1 : cpath.length); // +1 for ','\r\n\t\t\t\tlet oldSubPath = JSON.parse('[' + subPath + ']');\r\n\r\n\t\t\t\tlet oldSubVal = removeProxy(traversePath(oldVal, oldSubPath));\r\n\t\t\t\tlet newSubVal = removeProxy(traversePath(newVal, oldSubPath));\r\n\r\n\t\t\t\tif (oldSubVal !== newSubVal) {\r\n\t\t\t\t\tlet callbacks = this.subs_[name];\r\n\t\t\t\t\tif (callbacks.length) {\r\n\t\t\t\t\t\tlet fullSubPath = JSON.parse('[' + name + ']');\r\n\t\t\t\t\t\tfor (let callback of callbacks)  // [below] \"this.obj_\" so it has the context of the original object.\r\n\t\t\t\t\t\t\tcallback.apply(this.obj_, [action, fullSubPath, newSubVal, oldSubVal]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param path {string|string[]}\r\n\t * @param callback {function(action:string, path:string[], value:string?)} */\r\n\tsubscribe_(path, callback) {\r\n\t\tif (path.startsWith) // is string\r\n\t\t\tpath = [path];\r\n\r\n\t\t// Create property at top level path, even if we're only watching something much deeper.\r\n\t\t// This way we don't have to worry about overriding properties created at deeper levels.\r\n\t\tvar self = this;\r\n\t\tvar field = path[0];\r\n\r\n\t\tif (!(field in self.fields_)) {\r\n\t\t\tself.fields_[field] = self.obj_[field];\r\n\r\n\t\t\t// If we're subscribing to something within the top-level field for the first time,\r\n\t\t\t// then define it as a property that forward's to the proxy.\r\n\t\t\tdelete self.obj_[field];\r\n\t\t\tObject.defineProperty(self.obj_, field, {\r\n\t\t\t\tenumerable: 1,\r\n\t\t\t\tconfigurable: 1,\r\n\t\t\t\tget: () => self.proxy_[field],\r\n\t\t\t\t//set: (val) => self.obj_.$disableWatch ? self.proxy_.$removeProxy[field] = val : self.proxy_[field] = val\r\n\t\t\t\tset: function(val) {\r\n\t\t\t\t\tif (self.obj_.$disableWatch) // used by traversePath to watchlessly set.\r\n\t\t\t\t\t\tself.proxy_.$removeProxy[field] = val;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tself.proxy_[field] = val;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\r\n\t\t// Create the full path if it doesn't exist.\r\n\t\t// TODO: Can this part be removed?\r\n\t\ttraversePath(this.fields_, path, 1);\r\n\r\n\r\n\t\t// Add to subscriptions\r\n\t\tlet cpath = csv(path);\r\n\t\tif (!(cpath in self.subs_))\r\n\t\t\tself.subs_[cpath] = [];\r\n\t\tself.subs_[cpath].push(callback);\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param path{string[]|string}\r\n\t * @param {function?} callback Unsubscribe this callback.  If not specified, all callbacks willb e unsubscribed. */\r\n\tunsubscribe_(path, callback) {\r\n\r\n\t\t// Make sure path is an array.\r\n\t\tif (path.startsWith) // is string\r\n\t\t\tpath = [path];\r\n\r\n\t\t// Remove the callback from this path and all parent paths.\r\n\t\tlet cpath = csv(path);\r\n\t\tif (cpath in this.subs_) {\r\n\r\n\t\t\t// Remove the callback from the subscriptions\r\n\t\t\tif (callback) {\r\n\t\t\t\tlet callbackIndex = this.subs_[cpath].indexOf(callback);\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\tif (callbackIndex === -1)\r\n\t\t\t\t\tthrow new XElementError('Bad index');\r\n\t\t\t\t//#ENDIF\r\n\t\t\t\tthis.subs_[cpath].splice(callbackIndex, 1); // splice() modifies array in-place\r\n\t\t\t}\r\n\r\n\t\t\t// If removing all callbacks, or if all callbacks have been removed:\r\n\t\t\tif (!callback || !this.subs_[cpath].length) {\r\n\r\n\t\t\t\t// Remove the whole subscription array if there's no more callbacks\r\n\t\t\t\tdelete this.subs_[cpath];\r\n\r\n\t\t\t\t// Undo the Object.defineProperty() call when there are no more subscriptions to it.\r\n\t\t\t\t// If there are no subscriptions that start with propCPath\r\n\t\t\t\t// TODO This can be VERY SLOW when an object has many subscribers.  Such as an x-loop with hundreds of children.\r\n\t\t\t\t// If the loop tries to remove every child at once the complexity is O(n^2) because each child must search every key in this.subs_.\r\n\t\t\t\t// We need to find a faster way.\r\n\t\t\t\tlet propCpath = csv([path[0]]);\r\n\t\t\t\tif (!hasKeyStartingWith(this.subs_, propCpath)) {\r\n\r\n\t\t\t\t\tdelete this.obj_[path[0]]; // Remove the defined property.\r\n\t\t\t\t\tthis.obj_[path[0]] = this.fields_[path[0]]; // reset original unproxied value to object.\r\n\r\n\t\t\t\t\tdelete this.fields_[path[0]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param obj {object}\r\n * @param path {string|string[]}\r\n * @param callback {function(action:string, path:string[], value:string?)} */\r\nvar watch = (obj, path, callback) => {\r\n\tobj = removeProxy(obj);\r\n\r\n\t// Keep only one WatchProperties per watched object.\r\n\tvar wp = watch.objects.get(obj);\r\n\tif (!wp)\r\n\t\twatch.objects.set(obj, wp = new WatchProperties(obj));\r\n\r\n\twp.subscribe_(path, callback);\r\n};\r\n\r\n\r\n/**\r\n * Keeps track of which objects we're watching.\r\n * That way watch() and unwatch() can work without adding any new fields to the objects they watch.\r\n * @type {WeakMap<object, WatchProperties>} */\r\nwatch.objects = new WeakMap();\r\n\r\n/**\r\n *\r\n * @param obj {object}\r\n * @param path {string|string[]}\r\n * @param callback {function=} If not specified, all callbacks will be unsubscribed. */\r\nvar unwatch = (obj, path, callback) => {\r\n\tobj = removeProxy(obj);\r\n\tvar wp = watch.objects.get(obj);\r\n\r\n\tif (wp) {\r\n\t\tif (path) // unsubscribe only from path.\r\n\t\t\twp.unsubscribe_(path, callback);\r\n\t\telse // unsubscribe rom all paths.\r\n\t\t\tfor (let sub in wp.subs_)\r\n\t\t\t\twp.unsubscribe_(sub);\r\n\r\n\t\t// Remove from watched objects if we're no longer watching\r\n\t\tif (!Object.keys(wp.subs_).length)\r\n\t\t\twatch.objects.delete(obj);\r\n\t}\r\n};\r\n\r\nwatch.cleanup = () => watch.objects = new WeakMap();\r\n\r\n\r\n\r\nexport { watch, unwatch, WatchProperties};","/**\r\n * A WeakMap with multiple values per key. */\r\nvar WeakMultiMap = function () {\r\n\r\n\tlet self = this;\r\n\tself.items = new WeakMap();\r\n\r\n\t/**\r\n\t * Add an item to the map.  If it already exists, add another at the same key.\r\n\t * @param key\r\n\t * @param value */\r\n\tself.add = function (key, value) {\r\n\t\tlet itemSet = self.items.get(key);\r\n\t\tif (!itemSet)\r\n\t\t\tself.items.set(key, [value]);\r\n\t\telse\r\n\t\t\titemSet.push(value);\r\n\t};\r\n\r\n\t/**\r\n\t * Retrieve an item from the set that matches key and all values specified.\r\n\t * @param key\r\n\t * @returns {*|undefined} */\r\n\tself.get = function (key) {\r\n\t\treturn self.items.get(key)[0];\r\n\t};\r\n\r\n\tself.getAll = function (key) {\r\n\t\treturn self.items.get(key) || [];\r\n\t};\r\n\r\n\t// remove last item added.\r\n\tself.remove = function (key) {\r\n\t\tlet itemSet = self.items.get(key);\r\n\t\tif (!itemSet)\r\n\t\t\treturn undefined;\r\n\t\tif (itemSet.length === 1) // remove on last item\r\n\t\t\tself.items.delete(key);\r\n\t\treturn itemSet.pop();\r\n\t};\r\n\r\n\tself.removeAll = function (key) {\r\n\t\treturn self.items.delete(key);\r\n\t}\r\n\r\n};\r\nexport {WeakMultiMap};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Multi key lookup version.  Might not need this added complexity.\r\n// var WeakMultiMap2 = function() {\r\n//\r\n// \tlet self = this;\r\n// \tself.items = new WeakMap();\r\n//\r\n// \t// TODO: write an internal function that combines common elements of these functions\r\n//\r\n//\r\n// \t/**\r\n// \t * Add an item to the map.  If it already exists, add another at the same key.\r\n// \t * @param key\r\n// \t * @param values */\r\n// \tself.add = function(key, ...values) {\r\n// \t\tlet itemSet = self.items.get(key);\r\n// \t\tif (!itemSet)\r\n// \t\t\tself.items.set(key, [values]);\r\n// \t\telse\r\n// \t\t\titemSet.push(values);\r\n// \t};\r\n//\r\n// \t/**\r\n// \t * Retrieve an item from the set that matches key and all values specified.\r\n// \t * @param key\r\n// \t * @param values\r\n// \t * @returns {*|undefined} */\r\n// \tself.get = function(key, ...values) {\r\n// \t\tlet itemSet = self.items.get(key);\r\n// \t\tif (itemSet) {\r\n// \t\t\tfor (let item of itemSet) {\r\n// \t\t\t\tif (arrayEq(item.slice(0, values.length), values, true))\r\n// \t\t\t\t\treturn item;\r\n// \t\t\t}\r\n// \t\t}\r\n// \t\treturn undefined;\r\n// \t};\r\n//\r\n// \tself.getAll = function(key, ...values) {\r\n// \t\tlet result = [];\r\n// \t\tlet itemSet = self.items.get(key);\r\n// \t\tif (itemSet) {\r\n// \t\t\tfor (let item of itemSet) {\r\n// \t\t\t\tlet matches = true;\r\n// \t\t\t\tfor (let i = 0; i < values.length; i++) {\r\n// \t\t\t\t\tif (!eq(item[i], values[i])) {\r\n// \t\t\t\t\t\tmatches = false;\r\n// \t\t\t\t\t\tbreak;\r\n// \t\t\t\t\t}\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\t// Return the first item in the array that matches.\r\n// \t\t\t\tif (matches)\r\n// \t\t\t\t\tresult.push(item);\r\n// \t\t\t}\r\n// \t\t}\r\n//\r\n//\r\n// \t\treturn result;\r\n// \t};\r\n//\r\n// \t// remove first match\r\n// \tself.remove = function(key, ...values) {\r\n// \t\tlet itemSet = self.items.get(key);\r\n// \t\tif (itemSet) {\r\n// \t\t\tfor (let j=0; j<itemSet.length; j++) {\r\n// \t\t\t\tlet item = itemSet[j];\r\n// \t\t\t\tlet matches = true;\r\n// \t\t\t\tfor (var i = 0; i < values.length; i++) {\r\n// \t\t\t\t\tif (!eq(item[i], values[i])) {\r\n// \t\t\t\t\t\tmatches = false;\r\n// \t\t\t\t\t\tbreak;\r\n// \t\t\t\t\t}\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\t// Return the first item in the array that matches.\r\n// \t\t\t\tif (matches) {\r\n// \t\t\t\t\titemSet.splice(j, 1);\r\n// \t\t\t\t\treturn item;\r\n// \t\t\t\t}\r\n// \t\t\t}\r\n// \t\t}\r\n// \t\treturn undefined;\r\n// \t};\r\n//\r\n// };","import {XElementError} from \"./utils.js\";\r\n\r\nvar createElMap = {};\r\n\r\n\r\nvar createEl = (html) => {\r\n\tlet existing = createElMap[html];\r\n\tif (existing)\r\n\t\treturn existing.cloneNode(true);\r\n\r\n\r\n\t//#IFDEV\r\n\tif (typeof html !== 'string')\r\n\t\tthrow new XElementError('Html argument must be a string.');\r\n\t//#ENDIF\r\n\r\n\tlet tagName = html.trim().match(/<([a-z0-9-]+)/i);\r\n\tif (tagName)\r\n\t\ttagName = tagName[1];\r\n\r\n\t// Using a template makes some embed related tests fail to instantiate x-elements.\r\n\tlet parentMap = {\r\n\t\ttd: 'tr',\r\n\t\ttr: 'tbody',\r\n\t\ttbody: 'table',\r\n\t\tthead: 'table',\r\n\t\ttfoot: 'table',\r\n\t\tsource: 'video',\r\n\t\tarea: 'map',\r\n\t\tlegend: 'fieldset',\r\n\t\toption: 'select',\r\n\t\tcol: 'colgroup',\r\n\t\tparam: 'object'\r\n\t};\r\n\tlet parentTag = parentMap[tagName] || 'div';\r\n\r\n\tvar parent = document.createElement(parentTag);\r\n\tparent.innerHTML = html;\r\n\tvar result = parent.removeChild(parent.firstChild);\r\n\r\n\tcreateElMap[html] = result.cloneNode(true);\r\n\treturn result; // clone so that subsequent changes don't break our cache.\r\n};\r\n\r\n\r\nexport {createEl};","/*\r\nInherit from XElement to create custom HTML Components.\r\n\r\n\r\nTODO: major bugfixes\r\nImporting css in an xelement doesn't apply unless the same css file is imported in the main document.\r\nRemoving a node that contains an xelement doesn't remove its items from elWatches or elsewhere?\r\n\tHow to unittest this, since I can't inspect what's in weakmap?\r\n\tThis can be tested in the test app by opening multiple programs.\r\nWrite a better parser for expr.replace(/this/g, 'parent');\r\nparseVars(\"this.passthrough(x)\") doesn't find x.\r\nparseVars(\"item + passthrough('')\") finds \"passthrough\" as a variable.\r\nWrite a getWatches(el, expr) function that calls replaceVars, addThis, parseVars, an getRootXElement\r\n\tto give back\r\nDocument all properties that bindings.loop() sets on elements.\r\nWon't bind to properties on the class itself, insead of those defined within constructor.  Because they are called after the super constructor!\r\nUse a regex or parser to remove the html of x-loops before they're passed to createEl().  This can remove the check at the top of initHtml() and the .initialized property.\r\nMake sure recursive embeds work if:  1. the x-loop is on the x-parent above the shadow dom.  2. An x-element is within a div inside the loop.\r\n\r\nTODO: next goals:\r\nAllow defining and assigning to id=\"\" properties only in the constructor, and only a null value or something.  That way TypeScript can know about them without throwing errors.\r\n\r\nrewrite loop code to let [key, value] = loop(array); or something that parses as valid javascript.  That way we can eventually make it a js language injection for IntelliJ.\r\nfor (const [key, value] of Object.entries(animals))\r\nfor (const [key, value] of loop(animals))\r\nStill very verbose compared to the current syntax.\r\n\r\nRemove proxy if name begins or ends with a $?  Warn about bound varaibles beginning with $.  And this will only work if the val is a proxy.  I need a way to let it do nothing if it's not a proxy.\r\nWhen an x-prop calls a function, and that function throws an error, we don't see it in chrome's stack trace.\r\n{{var}} in text and attributes, and stylesheets?\r\nFix failing Edge tests.\r\nallow comments in loops.\r\nx-elements in loops get fully initialized then replaced.  Is this still true?\r\n\r\n\r\n\r\n\r\nFinish making shadowdom optional.\r\n\r\nimplement other binding functions.\r\nallow loop over slots if data-loop is on the instantiation.\r\nallow loop over more than one html tag.\r\ncache results of parseVars() and other parse functions?\r\nfunctions to enable/disable updates.\r\nfunction to trigger updates?  Or a callback to apply all updates before DOM is updated.\r\n\r\ncreate from <template> tag\r\nWhen a change occurs, create a Set of functions to call, then later call them all.\r\n\tThat way we remove some duplicate updates.\r\nAuto bind to this in complex expressions if the class property already exists and the var is otherwise undefined?\r\nimprove minifcation.\r\nExpose bindings prop in minified version to allow plugins.\r\nnon-ascii variable names.\r\nthrottle, debounce? data-val only trigger on change.  \r\n\tE.g. x-val:debounce(100)=\"\"  x-visible:fadeIn(100)=\"\" x-visible:fadeOut(10)=\"\"\r\n\tor x-val=\"debounce(prop, 100)\" ?\r\n\tThe latter will be better accomodated by IDEs since there's not an infinite number of attribute names to add.\r\n\tIdeally it would support calling a function on change, after a debounce, with the before and after values.\r\n\t\tThis would make it easily pluggable into an undo/redo system.\r\n\tHow to handle debounce times in both directions?  Setting the prop to update the form, and setting the form value to update the prop?\r\nAuto two-way bind for simple variables?\r\nbind to <input type=\"file\">\r\nbind to drag and drop areas for files?\r\nbind to clipboard events\r\nNamed slot support? - https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots\r\nSeparate out a lite version that doesn't do binding?\r\n\tThis would also make the code easier to follow.  But what to call it?  XEl ? XElementLite?\r\nallow ${text} variables in nested styles?\r\nwarning on loop element id.\r\n\r\nDisadvantages of Vue.js\r\n10x larger.\r\nRequires a single, special root component everything else must be within.\r\nDoesn't use es6 classes.\r\nRequires data and methods, can't bind directly to class props.\r\nDoesn't support ShadowDOM, only emulates nested styles.\r\nRequires key=\"\" attributes everywhere to make identical elements unique.\r\nVue.js doesn't watch array indices or object property add/remove!\r\n   Every time you assign have to call Vue.set(array...)\r\ndata: {} items shared between each component instance, unless it's wrapped in a function.\r\nNo id's to class properties.\r\n\r\nAdvantages of Vue.js\r\nFast and debugged.\r\nWidespread use.\r\nIDE support\r\n---\r\n{{ templates }} for plain text.\r\ntransition effects\r\nAutomatically adds vendor prefixes for data-styles=\"\" binding.\r\nkey/value iteration over objects.\r\nCheckboxes and <select multiple> to array of names.\r\nlazy modifier for input binding, to only trigger update after change.\r\n\r\n*/\r\n\r\nimport {safeEval} from './safeEval.js';\r\nimport {eventNamesMap, isValidAttribute, traversePath, removeProxy} from './utils.js';\r\nimport {addThis, isStandaloneCall, parseVars, replaceVars} from './parseVars.js';\r\nimport {unwatch} from './watch.js';\r\nimport {bindings} from './bindings.js';\r\nimport {WeakMultiMap} from \"./WeakMultiMap.js\";\r\nimport {createEl} from \"./createEl.js\";\r\n\r\n/**\r\n * A map between elements and the callback functions subscribed to them.\r\n * Each value is an array of objects with path and callback function.\r\n * @type {WeakMultiMap<HTMLElement, {path_:string, callback_:function}[]>} */\r\nvar elWatches = new WeakMultiMap();\r\n\r\n\r\n/**\r\n * A map between elements and the events assigned to them. *\r\n * @type {WeakMultiMap<HTMLElement, *[]>} */\r\nvar elEvents = new WeakMultiMap();\r\n\r\n\r\n/**\r\n * @param cls {Function}\r\n * @returns {string} */\r\nvar getXName = (cls) => {\r\n\tif (!cls.xname_) {\r\n\t\tlet lname =  'x-' + cls.name.toLowerCase().replace(/^x/, '');\r\n\t\tcls.xname_ = lname;\r\n\r\n\t\t// If name exists, add an incrementing integer to the end.\r\n\t\t// TODO: Should I throw an error instead?\r\n\t\tfor (let i = 2; customElements.get(cls.xname_); i++)\r\n\t\t\tcls.xname_ = 'x-' + lname + i;\r\n\t}\r\n\treturn cls.xname_;\r\n};\r\n\r\n/**\r\n * Get the nearest XElement parent.\r\n * @param el {HTMLElement}\r\n * @returns {XElement} */\r\nvar getXParent = (el) => { // will error if not in an XParent.\r\n\twhile ((el = el.parentNode) && el && el.nodeType !== 11) {} // 11 is doc fragment\r\n\treturn el ? el.host : null;\r\n};\r\n\r\n\r\n/**\r\n * Follow the path to get the root XElement, returning it and the remaining path.\r\n * This is useful for watch()'ing the right elements with data-prop is used.\r\n * @param obj {object}\r\n * @param path {string[]}\r\n * @return {[XElement, string[]]} */\r\nvar getRootXElement = function(obj, path) {\r\n\tpath = path.slice();\r\n\tlet result = [obj, path.slice()];\r\n\r\n\t// Follow the path upward, assigning to obj at each step.\r\n\twhile (obj = obj[path.shift()])\r\n\t\tif (obj instanceof XElement)\r\n\t\t\tresult = [obj, path.slice()]; // .slice() to copy the path so that shift() doesn't modify our result.\r\n\r\n\treturn result;\r\n};\r\n\r\nvar getLoopCode_ = (el) => el.getAttribute && (el.getAttribute('x-loop') || el.getAttribute('data-loop'));\r\n\r\nvar getXAttrib = (el, name) => el.getAttribute && (el.getAttribute('x-' + name) || el.getAttribute('data-' + name));\r\n\r\nvar parseXAttrib = (name) => name.startsWith('x-') ? name.slice(2) : name.startsWith('data-') ? name.slice(5) : null;\r\n\r\n\r\nvar parseXAttrib2 = (name) => {\r\n\tvar parts = name.split(/:/g);\r\n\tvar functions = {};\r\n\tfor (let i=1; i<parts.length; i++) {\r\n\t\tlet [name, code] = parts[i].split('(');\r\n\t\tfunctions[name] = code.slice(0, -1); // remove trailing )\r\n\t}\r\n\treturn [parts[0], functions];\r\n};\r\n\r\n/**\r\n * Recursively process all the data- attributes in el and its descendants.\r\n * @param self {XElement}\r\n * @param el {HTMLElement}\r\n * @param context {object<string, string>[]=} A map of loop variable names to their absolute reference.\r\n * This allows us to do variable replacement:\r\n *     <div>data-loop=\"this.items : item\">\r\n *         <div data-val=\"item.name\">\r\n *  The looped item becomes:\r\n *         <div data-val=\"this.items[0].name\"> */\r\nvar bindEl = (self, el, context) => {\r\n\r\n\tbindElProps(self, el, context);\r\n\tbindElEvents(self, el, context, true);\r\n\r\n\t// TODO: assert() to make sure element isn't bound twice.\r\n};\r\n\r\n\r\nvar bindElProps = (xelement, el, context) => {\r\n\tcontext = context || [];\r\n\tcontext = context.slice();\r\n\r\n\r\n\t// Handle data-prop and\r\n\tif (el instanceof XElement) {\r\n\r\n\t\t// Bind instantiation attributes (to the parent, not ourselves)\r\n\t\tif (el !== xelement)\r\n\t\t\tfor (let attrName in el.instantiationAttributes) {\r\n\t\t\t\tlet val = el.instantiationAttributes[attrName];\r\n\t\t\t\tlet name = parseXAttrib(attrName);\r\n\t\t\t\tif (name && name !== 'prop') { // prop handled in init so it happens first.\r\n\t\t\t\t\tif (bindings[name]) // attr.value is code.\r\n\t\t\t\t\t\tbindings[name](xelement, val, el, context);\r\n\r\n\t\t\t\t\t//#IFDEV\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tthrow new XElementError(attrName);\r\n\t\t\t\t\t//#ENDIF\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t// Don't inherit within-element context from parent.\r\n\t\tel.propContext = (xelement.propContext || []).slice();\r\n\r\n\t\tlet prop = getXAttrib(el, 'prop');\r\n\t\tif (prop) {\r\n\r\n\t\t\t// Here we still need to use the inner context of the parent XElement because\r\n\t\t\t// prop may have variables within it that may need to be resolved.\r\n\t\t\tbindings.prop(xelement, prop, el, context); // adds a new context to the beginning of the array.\r\n\r\n\t\t\t// Then we add the new context item added by prop();\r\n\t\t\tcontext = [context[0], ...el.propContext];\r\n\t\t}\r\n\t\telse\r\n\t\t\tcontext = el.propContext.slice();\r\n\r\n\r\n\r\n\t\tfor (let attrName in el.definitionAttributes) {\r\n\t\t\tlet val = el.definitionAttributes[attrName];\r\n\t\t\tlet name = parseXAttrib(attrName);\r\n\t\t\tif (name && name !== 'prop') { // prop handled in init so it happens first.\r\n\t\t\t\tif (bindings[name]) // attr.value is code.\r\n\t\t\t\t\tbindings[name](el, val, el, context);\r\n\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow new XElementError(attrName);\r\n\t\t\t\t//#ENDIF\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\txelement = el;\r\n\t}\r\n\r\n\r\n\t// Seach attributes for data- bindings.\r\n\telse if (el.attributes) { // shadow root has no attributes.\r\n\t\tfor (let attr of el.attributes) {\r\n\t\t\tlet attrName = parseXAttrib(attr.name);\r\n\t\t\tif (attrName && attrName !== 'prop') { // prop handled in init so it happens first.\r\n\t\t\t\tif (bindings[attrName]) // attr.value is code.\r\n\t\t\t\t\tbindings[attrName](xelement, attr.value, el, context);\r\n\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow new XElementError(attrName);\r\n\t\t\t\t//#ENDIF\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\t// Data loop already binds its own children when first applied.\r\n\t// So we don't iterate into those children.\r\n\tif (!getLoopCode_(el)) {\r\n\r\n\t\t// Allow traversing from host element into its own shadowRoot\r\n\t\tlet next = el.shadowRoot || el;\r\n\r\n\t\tfor (let child of next.children)\r\n\t\t\tbindElProps(xelement, child, context);\r\n\t}\r\n};\r\n\r\n\r\n\r\n/**\r\n * We rebind event attributes because otherwise there's no way\r\n * to make them call the class methods.\r\n * @param xelement {XElement}\r\n * @param el {HTMLElement}\r\n * @param context {object<string, string>=}\r\n * @param recurse {boolean=false}\r\n * @param getAttributesFrom {HTMLElement=} */\r\nvar bindElEvents = (xelement, el, context, recurse, getAttributesFrom) => {\r\n\r\n\r\n\tgetAttributesFrom = getAttributesFrom || el;\r\n\tif (getAttributesFrom.getAttribute) { // if not document fragment\r\n\r\n\t\t// Make copy because we remove them as we go.\r\n\t\tvar attribs = Array.prototype.slice.call(getAttributesFrom.attributes);\r\n\t\tfor (let attrib of attribs) {\r\n\r\n\t\t\tif (attrib.name in eventNamesMap) {\r\n\r\n\t\t\t\tlet eventName = attrib.name.substr(2); // remove \"on\" prefix.\r\n\t\t\t\tlet originalEventAttrib = attrib.value;\r\n\r\n\t\t\t\tlet code = replaceVars(originalEventAttrib, context);\r\n\r\n\t\t\t\t// If it's a simple function that exists in the class,\r\n\t\t\t\t// add the \"this\" prefix.\r\n\t\t\t\tlet path = parseVars(code, 0, 1)[0];\r\n\t\t\t\tif (path && traversePath(xelement, path) instanceof Function)\r\n\t\t\t\t\tcode = addThis(code, context, isStandaloneCall);\r\n\r\n\t\t\t\t// The code in the attribute can reference:\r\n\t\t\t\t// 1. event, assigned to the current event.\r\n\t\t\t\t// 2. this, assigned to the class instance.\r\n\t\t\t\tlet callback = function (event) {\r\n\r\n\t\t\t\t\teval(code);\r\n\r\n\t\t\t\t\t// TODO: Make safeEval() work here.  It currently fails bc it has the wrong xelement.\r\n\t\t\t\t\t// Try this again after we redo event binding in initHtml().\r\n\t\t\t\t\t//safeEval.call(xelement, code, {event: event}, true);\r\n\t\t\t\t}.bind(xelement);\r\n\r\n\t\t\t\tel.addEventListener(eventName, callback);\r\n\r\n\t\t\t\t// Save everything we'll need to restore it later.\r\n\t\t\t\telEvents.add(el, [eventName, callback, originalEventAttrib, xelement]);\r\n\r\n\t\t\t\t// Remove the original version so it doesn't also fire.\r\n\t\t\t\tel.removeAttribute(attrib.name);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (recurse) {\r\n\t\t// Allow traversing from host element into its own shadowRoot\r\n\t\tlet next = el.shadowRoot || el;\r\n\t\tif (el instanceof XElement)\r\n\t\t\txelement = el;\r\n\r\n\t\t// data-loop handles its own children.\r\n\t\tif (!getLoopCode_(next))\r\n\t\t\tfor (let child of next.children)\r\n\t\t\t\tbindElEvents(xelement, child, context, true);\r\n\t}\r\n};\r\n\r\n\r\n\r\n\r\n/**\r\n * Unbind properties and events from the element.\r\n * @param xelement {XElement|HTMLElement}\r\n * @param el {HTMLElement=} Remove all bindings within root and children. Defaults to self. */\r\nvar unbindEl = (xelement, el) => {\r\n\tel = el || xelement;\r\n\r\n\tvar next = el.shadowRoot || el;\r\n\r\n\t// Recursively unbind children.\r\n\tfor (let child of next.children) {\r\n\r\n\t\t// Change xelement reference as we descend into other xelements.\r\n\t\t// This is needed for test prop.unbindChild()\r\n\t\tif (child instanceof XElement)\r\n\t\t\tunbindEl(child, child);\r\n\t\telse\r\n\t\t\tunbindEl(xelement, child);\r\n\t}\r\n\r\n\t// Unbind properties\r\n\tif (el.attributes)\r\n\t\tfor (let attr of el.attributes) {\r\n\t\t\tif (attr.name.startsWith('x-') || attr.name.startsWith('data-')) {\r\n\r\n\t\t\t\tif ((attr.name === 'x-loop' || attr.name === 'data-loop') && el.loopHtml_) {\r\n\t\t\t\t\tel.innerHTML = el.loopHtml_; // revert it back to the look template element.\r\n\t\t\t\t\tdelete el.loopHtml_;\r\n\t\t\t\t\tdelete el.items_;\r\n\t\t\t\t\tdelete el.context_;\r\n\t\t\t\t\tdelete el.propContext;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// New\r\n\t\t\t\tlet watches = elWatches.getAll(el);\r\n\t\t\t\tfor (let w of watches)\r\n\t\t\t\t\tunwatch(...w);\r\n\t\t\t\telWatches.removeAll(el);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t// Unbind events\r\n\tlet ee = elEvents.getAll(el) || [];\r\n\tfor (let item of ee) { //  item is [event:string, callback:function, originalCode:string, root:XElement]\r\n\r\n\t\t// Only unbind if it was bound from the same root.\r\n\t\t// This is needed to allow onclick=\"\" attributes on both the definition and instantiation of an element,\r\n\t\t// and having their \"this\" bound to themselves or the parent element, respectively.\r\n\t\tif (item[3] === xelement) {\r\n\t\t\tel.removeEventListener(item[0], item[1]);\r\n\t\t\tif (item[2])\r\n\t\t\t\tel.setAttribute('on' + item[0], item[2]);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\nvar setAttribute = (self, name, value) => {\r\n\r\n\t// Copy to class properties.\r\n\t// This doesn't work because the properties aren't created until after initHtml() is called.\r\n\tif (!isValidAttribute(self, name)) {\r\n\r\n\t\t// As javascript code to be evaluated.\r\n\t\t// TODO: Should this feature be deprecated or moved to data-properties  Overlap with data-prop?\r\n\t\tif (value && value.length > 2 && value.startsWith('{') && value.endsWith('}')) {\r\n\t\t\tself[name] = safeEval.call(self, value.slice(1, -1)); // code to eval\r\n\t\t}\r\n\t\telse\r\n\t\t\tself[name] = value;\r\n\t}\r\n\r\n\t// Copy attribute as an attribute.\r\n\telse\r\n\t\tself.setAttribute(name, value);\r\n};\r\n\r\n\r\nvar initHtml = (self) => {\r\n\r\n\tif (!self.init_) {\r\n\r\n\t\tself.init_ = 1;\r\n\r\n\t\t//#IFDEV\r\n\t\tif (!self.constructor.html_)\r\n\t\t\tthrow new XElementError('XElement .html property must be set to a non-empty string.');\r\n\t\t//#ENDIF\r\n\r\n\t\t// If a child of a loop, before loop is initialized.\r\n\t\tif (self.parentNode && getXAttrib(self.parentNode, 'loop')) {\r\n\t\t\tself.parentNode.loopHtml = self.constructor.html_.trim();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 1. Create temporary element.\r\n\t\tXElement.disableBind++;\r\n\t\tvar definition = createEl(self.constructor.html_.trim()); // html_ is set from ClassName.html = '...'\r\n\t\tXElement.disableBind--;\r\n\r\n\r\n\t\t// Save definition attributes\r\n\t\tfor (let attr of definition.attributes)\r\n\t\t\tself.definitionAttributes[attr.name] = attr.value;\r\n\r\n\t\t// 2. Remove and save attributes from instantiation.\r\n\t\tfor (let attr of self.attributes) // From instantiation.\r\n\t\t\tself.instantiationAttributes[attr.name] = attr.value;\r\n\r\n\t\t// 3.  Add attributes from definition (Item.html='<div attr=\"value\"')\r\n\t\tfor (let attr of definition.attributes) { // From definition\r\n\t\t\tif (attr.name)\r\n\t\t\t\tsetAttribute(self, attr.name, attr.value);\r\n\t\t}\r\n\r\n\t\t// 4. Bind events on the defintion to functions on its own element and not its container\r\n\t\t// TODO: Remove this line and make the bindElEvents() smart enough to know what to do on its own, like we did with bindElProps()\r\n\t\tbindElEvents(self, self, null, false, definition);\r\n\r\n\t\t// 5.  Add attributes from instantiation.\r\n\t\tfor (let name in self.instantiationAttributes) // From instantiation\r\n\t\t\tsetAttribute(self, name, self.instantiationAttributes[name]);\r\n\r\n\t\t// 6. Create children\r\n\r\n\t\t// As Shadow DOM\r\n\t\tlet mode = self.constructor.shadowMode;\r\n\t\tif (!mode)\r\n\t\t\tmode = 'open';\r\n\r\n\t\tif (mode === 'open' || mode === 'closed') {\r\n\t\t\tself.attachShadow({mode: mode});\r\n\t\t\twhile (definition.firstChild)\r\n\t\t\t\tself.shadowRoot.insertBefore(definition.firstChild, null);\r\n\r\n\t\t}\r\n\t\telse { // mode == 'none'\r\n\r\n\t\t\t// without\r\n\t\t\t// Html within <x-classname>...</x-classname>, where the tag is added to another element.\r\n\t\t\t// This only works in the Edge shim.  It's an empty string in chrome and firefox.\r\n\t\t\tvar slotHtml = self.innerHTML;\r\n\t\t\tvar slot = definition.querySelector('#slot');\r\n\t\t\tif (slot)\r\n\t\t\t\tslot.removeAttribute('id');\r\n\r\n\t\t\t// Copy children from temporary div to this class.\r\n\t\t\tif (slot || !slotHtml) {\r\n\t\t\t\tself.innerHTML = '';\r\n\t\t\t\twhile (definition.firstChild)\r\n\t\t\t\t\tself.appendChild(definition.firstChild);\r\n\t\t\t}\r\n\r\n\t\t\t// Copy children from <x-classname> into the slot.\r\n\t\t\tif (slotHtml)\r\n\t\t\t\t(slot || self).innerHTML = slotHtml;\r\n\t\t}\r\n\r\n\t\tvar root = self.shadowRoot || self;\r\n\r\n\t\t// 7. replace link tags with inline styles, if the style has already been added to the outermost document.\r\n\t\t// This prevents making an http request for each one when the server doesn't have caching.  (e.g. during development)\r\n\t\tfor (let link of root.querySelectorAll('link')) {\r\n\t\t\tfor (let stylesheet of document.styleSheets)\r\n\t\t\t\tif (stylesheet.href === link.href) {\r\n\t\t\t\t\tlink.parentNode.replaceChild(\r\n\t\t\t\t\t\tXElement.createEl(\r\n\t\t\t\t\t\t\t'<style>' +\r\n\t\t\t\t\t\t\tArray.from(stylesheet.cssRules).map(x => x.cssText).join('\\n') +\r\n\t\t\t\t\t\t\t'</style>'),\r\n\t\t\t\t\t\tlink);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// 8. Create class properties that reference any html element with an id tag.\r\n\t\tfor (let node of root.querySelectorAll('[id]')) {\r\n\t\t\tlet id = node.getAttribute('id');\r\n\r\n\t\t\t//#IFDEV\r\n\t\t\t// Make sure we're not replacing an existing method.\r\n\t\t\tif (id in self && self[id] instanceof Function)\r\n\t\t\t\tthrow new XElementError('Cannot set property \"' + id + '\" on \"' + self.constructor.name +\r\n\t\t\t\t\t'\" because there is already a class method with the same name.');\r\n\t\t\t//#ENDIF\r\n\r\n\t\t\tObject.defineProperty(self, id, {\r\n\t\t\t\t// Make it readonly.\r\n\t\t\t\t// Using writeable: false caused errors if the getter returns a proxy instead of the proper type.\r\n\t\t\t\t// But how does it know it's the wrong type?\r\n\r\n\t\t\t\tenumerable: 1,\r\n\t\t\t\tconfigurable: 1,\r\n\t\t\t\tget: () => node,\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\tset: () => {\r\n\t\t\t\t\tthrow new XElementError('Property ' + id + ' not writable');\r\n\t\t\t\t}\r\n\t\t\t\t//#ENDIF\r\n\t\t\t});\r\n\r\n\t\t\t// Only leave the id attributes if we have a shadow root.\r\n\t\t\t// Otherwise we'll have duplicate id's in the main document.\r\n\t\t\tif (!self.shadowRoot)\r\n\t\t\t\tnode.removeAttribute('id');\r\n\t\t}\r\n\r\n\r\n\t\tif (XElement.disableBind === 0) {\r\n\r\n\t\t\t// 9. Bind all data- and event attributes\r\n\t\t\t// TODO: Move bind into setAttribute above, so we can call it separately for definition and instantiation?\r\n\t\t\tbindElProps(self, self);\r\n\r\n\r\n\t\t\t// We pass root to bind all events on this element's children.\r\n\t\t\t// We bound events on the element itself in a separate call to bindElEvents(self, self) above.\r\n\t\t\tbindElEvents(self, root, null, true);\r\n\t\t}\r\n\r\n\t\tself.initialized = true;\r\n\t}\r\n};\r\n\r\n/**\r\n * @extends HTMLElement\r\n * @extends Node\r\n * @property {HTMLElement} shadowRoot\r\n * Inherit from this class to make a custom HTML element.\r\n * If you extend from XElement, you can't instantiate your class unless you first set the html property.\r\n * This is because XElement extends from HTMLElement, and setting the .html property calls customElements.define(). */\r\nclass XElement extends HTMLElement {\r\n\r\n\tconstructor() {\r\n\t\t//#IFDEV\r\n\t\ttry {\r\n\t\t\t//#ENDIF\r\n\t\t\tsuper();\r\n\t\t\t//#IFDEV\r\n\t\t} catch (error) {\r\n\t\t\tif (error instanceof TypeError) // Add helpful message to error:\r\n\t\t\t\terror.message += '\\nMake sure to set the .html property before instantiating the class \"' + this.name + '\".';\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t\t//#ENDIF\r\n\r\n\t\t// Class properties\r\n\t\tthis.parent = undefined;\r\n\t\tthis.definitionAttributes = {};\r\n\t\tthis.instantiationAttributes = {};\r\n\r\n\r\n\t\tlet xname = getXName(this.constructor);\r\n\t\tlet self = this;\r\n\t\tif (customElements.get(xname))\r\n\t\t\tinitHtml(self);\r\n\t\telse\r\n\t\t\tcustomElements.whenDefined(xname).then(() => {\r\n\t\t\t\tinitHtml(self);\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * TODO: Use this function in more places.\r\n\t * @param expr {string}\r\n\t * @param context {object[]}\r\n\t * @returns {[XElement, string[]][]} Array of arrays, with each sub-array being a root and the path from it.  */\r\n\tgetWatchedPaths(expr, context) {\r\n\t\texpr = addThis(replaceVars(expr, context), context);\r\n\t\treturn parseVars(expr).map(\r\n\t\t\t(path)=>getRootXElement(this, path)\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Override the static html property so we can call customElements.define() whenever the html is set.*/\r\nObject.defineProperty(XElement, 'html', {\r\n\tget: () => this.html_,\r\n\tset: function (html) {\r\n\r\n\t\t// TODO: We want to be able to do:\r\n\t\t// <x-item arg1=\"1\", arg2=\"2\">\r\n\t\t// And have those passed to Item's constructor.\r\n\t\t// Here we can get the names of those arguments, but how to intercept the browser's call to the constructor?\r\n\t\t// Below I tried to work around this by subclassing.\r\n\t\t// But we can't get a reference to the <x-item> to read its attributes before the super() call.\r\n\t\t// const self = this;\r\n\t\t// function getConstructorArgs(func) {\r\n\t\t// \treturn func.toString()  // stackoverflow.com/a/14660057\r\n\t\t// \t\t.replace(/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,'') // Remove comments. TODO: Also remove strings.\r\n\t\t// \t\t.match(/^\\s*constructor\\s*\\(\\s*([^)]*)\\)\\s*{/m)[1] // submatch \"constructor(...) {\"\r\n\t\t// \t\t.split(/\\s*,\\s*/);\r\n\t\t// }\r\n\t\t// var args = getConstructorArgs(this);\r\n\t\t//\r\n\t\t// class Embedded extends this {\r\n\t\t// \tconstructor() {\r\n\t\t// \t\tvar attrib0 = this.getAttribute(args[0]); // fails.  Can't use \"this\".\r\n\t\t// \t\tsuper(attrib0);\r\n\t\t// \t}\r\n\t\t// }\r\n\r\n\t\t// Could the customElements.whenDefined() callback be helpful?\r\n\r\n\t\t// New way where we pass attributes to the constructor:\r\n\t\t// customElements.define(name, Embedded);\r\n\t\t// customElements.define(name+'-internal', this);\r\n\r\n\t\t// Old way:\r\n\t\tcustomElements.define(getXName(this), this);\r\n\r\n\t\treturn this.html_ = html.trim();\r\n\t}\r\n});\r\n\r\n// Exports\r\nXElement.disableBind = 0;\r\nXElement.bindings = bindings;\r\nXElement.createEl = createEl; // useful for other code.\r\nXElement.getXParent = getXParent;\r\nXElement.removeProxy = removeProxy;\r\n\r\nXElement.cleanup = () => {\r\n\telWatches = new WeakMultiMap();\r\n\telEvents = new WeakMultiMap();\r\n};\r\n\r\nexport { XElement, getRootXElement, getXParent, elWatches, elEvents, bindEl, unbindEl };\r\nexport {removeProxy, unwatch};\r\n\r\n// Used as a passthrough for xelement attrib debugging.\r\nwindow.xdebug = (a) => {\r\n\tdebugger;\r\n\treturn a;\r\n};\r\nwindow.xlog = (a) => {\r\n\tconsole.log(a);\r\n\treturn a;\r\n};","import {safeEval} from './safeEval.js';\r\nimport {arrayEq, traversePath, removeProxy, XElementError} from './utils.js';\r\nimport {addThis, isStandaloneVar, parseLoop, parseObj, parseVars, replaceVars, trimThis} from './parseVars.js';\r\nimport {watch} from './watch.js';\r\nimport {XElement, elEvents, elWatches, bindEl, unbindEl, getRootXElement, getXParent } from './xelement.js';\r\nimport {createEl} from \"./createEl.js\";\r\n\r\n// TODO: write a function to replace common code among these.\r\nvar bindings = {\r\n\r\n\t/**\r\n\t * When self.field changes, update the value of <el attr>.\r\n\t * This binding is used if one of the other names above isn't matched.\r\n\t * @param self {XElement}\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement}\r\n\t * @param context {object<string, string>} */\r\n\tattribs: (self, code, el, context) => {\r\n\t\tvar obj = parseObj(code);\r\n\t\tfor (let name in obj) {\r\n\t\t\tlet attrExpr = addThis(replaceVars(obj[name], context), context);\r\n\r\n\t\t\tlet setAttr = /*XElement.batch(*/function (/*action, path, value*/) {\r\n\t\t\t\tvar result = safeEval.call(self, attrExpr, {el: el});\r\n\t\t\t\tif (result === false || result === null || result === undefined)\r\n\t\t\t\t\tel.removeAttribute(name);\r\n\t\t\t\telse\r\n\t\t\t\t\tel.setAttribute(name, result + '');\r\n\t\t\t}/*)*/;\r\n\r\n\t\t\t// If the variables in code, change, execute the code.\r\n\t\t\t// Then set the attribute to the value returned by the code.\r\n\t\t\tfor (let path of parseVars(attrExpr)) {\r\n\t\t\t\tlet [root, pathFromRoot] = getRootXElement(self, path);\r\n\t\t\t\twatch(root, pathFromRoot, setAttr);\r\n\t\t\t\telWatches.add(el, [self,  path, setAttr]);\r\n\t\t\t}\r\n\r\n\t\t\tsetAttr();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @param self {XElement}\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement}\r\n\t * @param context {object<string, string>} */\r\n\tclasses: (self, code, el, context) => {\r\n\r\n\t\tvar obj = parseObj(code);\r\n\t\tfor (let name in obj) {\r\n\t\t\tlet classExpr = addThis(replaceVars(obj[name], context), context);\r\n\r\n\t\t\t// This code is called on every update.\r\n\t\t\tlet updateClass = /*XElement.batch*/() => {\r\n\t\t\t\tlet result = safeEval.call(self, classExpr, {el: el});\r\n\t\t\t\tif (result)\r\n\t\t\t\t\tel.classList.add(name);\r\n\t\t\t\telse {\r\n\t\t\t\t\tel.classList.remove(name);\r\n\t\t\t\t\tif (!el.classList.length) // remove attribute after last class removed.\r\n\t\t\t\t\t\tel.removeAttribute('class');\r\n\t\t\t\t}\r\n\t\t\t}/*)*/;\r\n\r\n\r\n\t\t\t// Create properties and watch for changes.\r\n\t\t\tfor (let path of parseVars(classExpr)) {\r\n\t\t\t\tlet [root, pathFromRoot] = getRootXElement(self, path);\r\n\t\t\t\twatch(root, pathFromRoot, updateClass);\r\n\t\t\t\telWatches.add(el, [root, pathFromRoot, updateClass]);\r\n\t\t\t}\r\n\r\n\t\t\t// Set initial values.\r\n\t\t\tupdateClass();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @param self {XElement}\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement}\r\n\t * @param context {object<string, string>} */\r\n\ttext: (self, code, el, context) => {\r\n\t\tcode = addThis(replaceVars(code, context), context);\r\n\t\tlet setText = (/*action, path, value, oldVal*/) => {\r\n\t\t\tlet val = safeEval.call(self, code, {el: el});\r\n\t\t\tif (val === undefined || val === null)\r\n\t\t\t\tval = '';\r\n\t\t\tel.textContent = val;\r\n\t\t};\r\n\t\tfor (let path of parseVars(code)) {\r\n\t\t\tlet [root, pathFromRoot] = getRootXElement(self, path);\r\n\t\t\twatch(root, pathFromRoot, setText);\r\n\t\t\telWatches.add(el, [root, pathFromRoot, setText]);\r\n\t\t}\r\n\r\n\t\t// Set initial value.\r\n\t\tsetText();\r\n\t},\r\n\r\n\t/**\r\n\t * @param self {XElement}\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement}\r\n\t * @param context {object<string, string>} */\r\n\thtml: (self, code, el, context) => {\r\n\t\tcode = addThis(replaceVars(code, context), context);\r\n\t\tlet setHtml = (/*action, path, value, oldVal*/) => {\r\n\t\t\tlet val = safeEval.call(self, code, {el: el});\r\n\t\t\tif (val === undefined || val === null)\r\n\t\t\t\tval = '';\r\n\t\t\tel.innerHTML = val;\r\n\t\t};\r\n\r\n\t\tfor (let path of parseVars(code)) {\r\n\t\t\tlet [root, pathFromRoot] = getRootXElement(self, path);\r\n\t\t\twatch(root, pathFromRoot, setHtml);\r\n\t\t\telWatches.add(el, [root,  pathFromRoot, setHtml]);\r\n\t\t}\r\n\r\n\t\t// Set initial value.\r\n\t\tsetHtml();\r\n\t},\r\n\r\n\r\n\t// TODO: Removing an item from the beginning of the array copy the first to the 0th,\r\n\t// then createEl a new 1st item before deleting it when rebuildChildren is called again with the delete operation.\r\n\t// Batching updates into a set should fix this.\r\n\t/**\r\n\t * @param self {XElement}\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement}\r\n\t * @param context {object<string, string>} */\r\n\tloop: (self, code, el, context) => {\r\n\t\tcontext = context || [];\r\n\r\n\t\t// Parse code into foreach parts\r\n\t\tlet [foreach, loopVar, indexVar] = parseLoop(code);\r\n\t\tforeach = replaceVars(foreach, context);\r\n\t\tforeach = addThis(foreach, context);\r\n\t\tel.context_ = context;  // Used in sortable.\r\n\r\n\t\t// Allow loop attrib to be applied above shadowroot.\r\n\t\tlet root = el;\r\n\r\n\t\t// If we're not looping over slots, set the root to the shadowRoot.\r\n\t\tif (el instanceof XElement && !el.instantiationAttributes['x-loop'] && !el.instantiationAttributes['data-loop'])\r\n\t\t\troot = root.shadowRoot || root;\r\n\r\n\t\tvar rebuildChildren = (action, path, value, oldVal, indirect) => {\r\n\r\n\t\t\t// The modification was actually just a child of the loop variable.\r\n\t\t\t// The loop variable itself wasn't assigned a new value.\r\n\t\t\t// Although indirect will also be true if adding or removing an item from the array.\r\n\t\t\t// If foreach is non-standaline, we don't know how the path will be evaluated to the array used by foreach.\r\n\t\t\t// So this is of no use right now.\r\n\t\t\tif (indirect) {\r\n\t\t\t\t/*\r\n\t\t\t\t// If deleting a single item from a list.\r\n\t\t\t\t// Commented out because this would only work with simple variables.\r\n\t\t\t\t// Maybe later I can find a better way.\r\n\t\t\t\tif (action==='delete') {\r\n\r\n\t\t\t\t\tdebugger;\r\n\t\t\t\t\tlet loopItem = traversePath(self, path.slice(0, -1));\r\n\t\t\t\t\t//if (loopItem === el) {\r\n\t\t\t\t\t\tlet index = path.slice(-1)[0];\r\n\t\t\t\t\t\tlet loopEl = el.shadowRoot || el;\r\n\t\t\t\t\t\tlet child = loopEl.children[index];\r\n\t\t\t\t\t\tunbindEl(child);\r\n\t\t\t\t\t\troot.removeChild(child);\r\n\t\t\t\t\t//}\r\n\t\t\t\t}*/\r\n\t\t\t\t//return;\r\n\t\t\t}\r\n\r\n\t\t\t// The code we'll loop over.\r\n\t\t\t// We store it here because innerHTML is lost if we unbind and rebind.\r\n\t\t\tif (!root.loopHtml_) {\r\n\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\tif (root.children.length !== 1)\r\n\t\t\t\t\tthrow new XElementError('x-loop=\"' + code + '\" must have exactly one child html element.  ' +\r\n\t\t\t\t\t\t'This restriction may be removed in the future.');\r\n\t\t\t\t//#ENDIF\r\n\r\n\t\t\t\troot.loopHtml_ = root.children[0].outerHTML.trim();\r\n\r\n\t\t\t\t// Remove children before calling rebuildChildren()\r\n\t\t\t\t// That way we don't unbind elements that were never bound.\r\n\t\t\t\twhile (root.lastChild)\r\n\t\t\t\t\troot.removeChild(root.lastChild);\r\n\t\t\t}\r\n\r\n\t\t\t//#IFDEV\r\n\t\t\tif (!root.loopHtml_)\r\n\t\t\t\tthrow new XElementError('x-loop=\"' + code + '\" rebuildChildren() called before bindEl().');\r\n\t\t\t//#ENDIF\r\n\r\n\t\t\t// We don't know how the path will be evaluated to the array used by foreach, so we re-evaluate it to find out.\r\n\t\t\t// TODO: Skip this step and just use the path directly for standalone paths.\r\n\t\t\tvar newItems = removeProxy(safeEval.call(self, foreach, {el: el}) || []);\r\n\t\t\tvar oldItems = removeProxy(root.items_ || []);\r\n\r\n\t\t\t// Do nothing if the array hasn't changed.\r\n\t\t\tif (arrayEq(oldItems, newItems, true))\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Set temporary index on each child, so we can track how they're re-ordered.\r\n\t\t\tfor (let i=0; i< root.children.length; i++)\r\n\t\t\t\troot.children[i].index_ = i;\r\n\r\n\t\t\t// Create a map from the old items to the elements that represent them.\r\n\t\t\t// This will fail if anything else has been changing the children order.\r\n\t\t\tvar oldMap = new Map();\r\n\t\t\tvar newSet = new Set(newItems);\r\n\t\t\tfor (let i=oldItems.length-1; i>=0; i--) {\r\n\t\t\t\tlet oldItem = oldItems[i];\r\n\t\t\t\tlet child = root.children[i];\r\n\r\n\t\t\t\t// And remove any elements that are no longer present.\r\n\t\t\t\tif (!newSet.has(oldItem)) {\r\n\t\t\t\t\tunbindEl(child);\r\n\t\t\t\t\troot.removeChild(child);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create a list of items we want to keep, indexed by their value.\r\n\t\t\t\t// If there are duplicates, we add them to the array.\r\n\t\t\t\t// This prevents us from destroying and recreating the same elements,\r\n\t\t\t\t// Which is slower and makes form elements lose focus while typing.\r\n\t\t\t\telse if (oldMap.has(oldItem))\r\n\t\t\t\t\toldMap.get(oldItem).push(child);\r\n\t\t\t\telse\r\n\t\t\t\t\toldMap.set(oldItem, [child]);\r\n\t\t\t}\r\n\r\n\t\t\t// Loop through newItems, creating and moving children as needed.\r\n\t\t\tfor (let i=0; i<newItems.length; i++) {\r\n\t\t\t\tlet oldChild = root.children[i];\r\n\t\t\t\tlet newChild = (oldMap.get(newItems[i]) || []).pop(); // last on, first off b/c above we iterate in reverse.\r\n\t\t\t\tlet isNew = !newChild;\r\n\r\n\t\t\t\t// If the existing child doesn't match the new item.\r\n\t\t\t\tif (!oldChild || oldChild !== newChild) {\r\n\r\n\t\t\t\t\t// Create a new one if needed.\r\n\t\t\t\t\t// TODO: createEl() binds nexted x-elements before we're ready for them to be bound.\r\n\t\t\t\t\t// E.g. below we set the localContext for loop variables.\r\n\t\t\t\t\tif (isNew) {\r\n\t\t\t\t\t\tXElement.disableBind ++;\r\n\t\t\t\t\t\tnewChild = createEl(root.loopHtml_);\r\n\t\t\t\t\t\tXElement.disableBind --;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// This can either insert the new one or move an old one to this position.\r\n\t\t\t\t\troot.insertBefore(newChild, oldChild);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If there are identical items in the array, some extras can be left at the end.\r\n\t\t\tfor (let i=root.children.length-1; i>=newItems.length; i--) {\r\n\t\t\t\tlet child = root.children[i];\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\tunbindEl(child);\r\n\t\t\t\t\troot.removeChild(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// Rebind events on any elements that had their index change.\r\n\t\t\tfor (let i=0; i<root.children.length; i++) {\r\n\t\t\t\tlet child = root.children[i];\r\n\t\t\t\tif (child.index_ !== i) {\r\n\r\n\t\t\t\t\tlet localContext =  {...context[0]};\r\n\r\n\t\t\t\t\t//#IFDEV\r\n\t\t\t\t\tif (loopVar in localContext)\r\n\t\t\t\t\t\tthrow new XElementError('Loop variable \"' + loopVar + '\" already used in outer loop.');\r\n\t\t\t\t\tif (indexVar && indexVar in localContext)\r\n\t\t\t\t\t\tthrow new XElementError('Loop index variable \"' + indexVar + '\" already used in outer loop.');\r\n\t\t\t\t\t//#ENDIF\r\n\r\n\t\t\t\t\t// TODO, if child is an xelement, this won't unbind any events within it!\r\n\r\n\t\t\t\t\t// If it wasn't just created:\r\n\t\t\t\t\t//if (child.hasOwnProperty('index_'))\r\n\t\t\t\t\tunbindEl(self, child);\r\n\r\n\t\t\t\t\tlocalContext[loopVar] = foreach + '[' + i + ']';\r\n\t\t\t\t\tif (indexVar !== undefined)\r\n\t\t\t\t\t\tlocalContext[indexVar] = i;\r\n\r\n\t\t\t\t\t// Save the context on every loop item.\r\n\t\t\t\t\t// This is necessary for updating the x-prop watch below.\r\n\t\t\t\t\t// TODO: That code is removed, so we no longer need this line.\r\n\t\t\t\t\tchild.context_ = localContext;\r\n\r\n\t\t\t\t\tbindEl(self, child, [localContext, ...context.slice(1)]);\r\n\t\t\t\t}\r\n\t\t\t\tdelete child.index_;\r\n\t\t\t}\r\n\r\n\t\t\t// Save the items on the loop element, so we can compare them to their modified values next time the loop is rebuilt.\r\n\t\t\troot.items_ = newItems.slice(); // copy TODO: Should this be el not root?\r\n\r\n\t\t\t// If it's a select element, reapply its x-val when its children change.\r\n\t\t\t// TODO: Should this also be done for <textarea> ?\r\n\t\t\tif (el.tagName === 'SELECT' && el.hasAttribute('x-val')) {\r\n\t\t\t\tlet code = addThis(replaceVars(el.getAttribute('x-val'), context), context);\r\n\t\t\t\tel.value = safeEval.call(self, code, {el: el});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let path of parseVars(foreach)) {\r\n\t\t\tlet [root, pathFromRoot] = getRootXElement(self, path);\r\n\t\t\twatch(root, pathFromRoot, rebuildChildren);\r\n\t\t\telWatches.add(el, [root, pathFromRoot, rebuildChildren]);\r\n\t\t}\r\n\r\n\t\t// Set initial children\r\n\t\trebuildChildren();\r\n\t},\r\n\r\n\t/**\r\n\t * @param self {XElement} A parent XElement\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement} An XElement that's a child of self, that has a data-prop attribute.\r\n\t * @param context {object<string, string>[]} */\r\n\tprop: (self, code, el, context) => {\r\n\r\n\t\t//#IFDEV\r\n\t\tif (!context)\r\n\t\t\tthrow new XElementError();\r\n\t\tif (!Array.isArray(context))\r\n\t\t\tthrow new XElementError();\r\n\t\tif (!(el instanceof XElement))\r\n\t\t\tthrow new XElementError('The data-prop and x-prop attributes can only be used on XElements in ' + code);\r\n\t\t//#ENDIF\r\n\r\n\t\t// allow binding only on instantiation and not definition\r\n\t\tif (self !== el) {\r\n\t\t\tel.parent = self;\r\n\r\n\t\t\tvar obj = parseObj(code);\r\n\t\t\tlet newContext = {};\r\n\t\t\tfor (let prop in obj) {\r\n\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\tif (prop === 'this')\r\n\t\t\t\t\tthrow new XElementError('Cannot use data-propx or x-prop to bind to \"this\" as a destination in ' + code);\r\n\t\t\t\t//#ENDIF\r\n\r\n\t\t\t\t// Add 'this' prefix to standaline variables.\r\n\t\t\t\tlet expr = obj[prop];\r\n\t\t\t\texpr = trimThis(expr);\r\n\t\t\t\texpr = replaceVars(expr, context);\r\n\t\t\t\texpr = addThis(expr, context);\r\n\r\n\r\n\t\t\t\t// Add the parent property to the context.\r\n\t\t\t\tlet expr2 = expr.replace(/this\\./g, 'parent\\.'); // TODO: temporary lazy way until I write actual parsing\r\n\t\t\t\texpr2 = expr2.replace(/this$/, 'parent');\r\n\t\t\t\tnewContext[prop] = expr2;\r\n\r\n\t\t\t\t// Create a property so we can access the parent.\r\n\t\t\t\t// This is often deleted and replaced by watch()\r\n\t\t\t\tlet descriptor = {\r\n\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\tget: function () {\r\n\t\t\t\t\t\treturn safeEval.call(self, expr);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// let paths = parseVars(expr);\r\n\t\t\t\t// for (let path of paths)\r\n\t\t\t\t// \twatch(self, path, () => {\r\n\t\t\t\t// \t\tel[prop] = safeEval.call(self, expr);\r\n\t\t\t\t// \t});\r\n\r\n\r\n\t\t\t\tObject.defineProperty(el, prop, descriptor);\r\n\r\n\r\n\t\t\t\t// Attempt 2:  fails the props test because\r\n\t\t\t\t// el.propGetter = function () {\r\n\t\t\t\t// \treturn safeEval.call(self, expr);\r\n\t\t\t\t// };\r\n\t\t\t\t//\r\n\t\t\t\t// // This will be replaced if something subscribes to prop.\r\n\t\t\t\t// Object.defineProperty(el, prop, {\r\n\t\t\t\t// \tconfigurable: true,\r\n\t\t\t\t// \tget: function () {\r\n\t\t\t\t// \t\treturn safeEval.call(self, expr);\r\n\t\t\t\t// \t},\r\n\t\t\t\t// \tset: function(val) {\r\n\t\t\t\t// \t\tlet paths = parseVars(expr);\r\n\t\t\t\t// \t\ttraversePath(self, paths[0], true, val);\r\n\t\t\t\t// \t}\r\n\t\t\t\t// });\r\n\r\n\t\t\t\t// Attempt 3: works except for embed, loopnested, and events:\r\n\t\t\t\t// Will probably cause too much redraw, as assigning a whole object will trigger updates of all its children.\r\n\t\t\t\t// let paths = parseVars(expr);\r\n\t\t\t\t// for (let path of paths) {\r\n\t\t\t\t// \tlet updateProp = function() {\r\n\t\t\t\t// \t\tel[prop] = safeEval.call(self, expr);\r\n\t\t\t\t//\r\n\t\t\t\t// \t};\r\n\t\t\t\t// \twatch(self, path, updateProp);\r\n\t\t\t\t// \telWatches.add(el,[self, path, updateProp]);\r\n\t\t\t\t// }\r\n\t\t\t\t//\r\n\t\t\t\t// el[prop] = safeEval.call(self, expr);\r\n\t\t\t}\r\n\r\n\t\t\tcontext.unshift(newContext);\r\n\t\t}\r\n\t},\r\n\r\n\t// Requires Sortable.js\r\n\t// does not support dynamic (watch) binding.\r\n\tsortable: (self, code, el, context) => {\r\n\t\tvar options = {};\r\n\r\n\t\t// Build arguments to send to Sortable.\r\n\t\tif (code) { // we also allow a bare sortable attribute with no value.\r\n\t\t\tvar obj = parseObj(code);\r\n\t\t\tfor (let name in obj) {\r\n\t\t\t\tlet expr = addThis(replaceVars(obj[name], context), context);\r\n\t\t\t\toptions[name] = safeEval.call(self, expr, {el: el});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If sorting items bound to a loop, and the variable is standaline,\r\n\t\t// then update the original array after items are dragged.\r\n\t\tvar loopCode = getLoopCode_(el);\r\n\t\tif (loopCode) {\r\n\r\n\t\t\tlet [foreach/*, loopVar, indexVar*/] = parseLoop(loopCode);\r\n\t\t\t//#IFDEV\r\n\t\t\tif (!isStandaloneVar(foreach))\r\n\t\t\t\tthrow new XElementError(\"Cannot bind sortable to non-standalone loop variable.\");\r\n\t\t\t//#ENDIF\r\n\r\n\r\n\t\t\t// Update the arrays after we drag items.\r\n\t\t\tvar moveItems = function(event) {\r\n\r\n\t\t\t\t// Update for sorting within a list.\r\n\t\t\t\t// Remove for dragging between lists, even if cloning.\r\n\t\t\t\t// Intercepting these events makes the variable el above always be the receiver.\r\n\t\t\t\tif (event.type === 'update' || (event.type === 'add')) {\r\n\t\t\t\t\tlet item;\r\n\r\n\t\t\t\t\t// Move the element back to where it came from.\r\n\t\t\t\t\tif (event.pullMode === 'clone')\r\n\t\t\t\t\t\tevent.to.removeChild(event.to.children[event.newIndex]);\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\titem = event.to.children[event.newIndex];\r\n\t\t\t\t\t\tevent.from.insertBefore(item, event.from.children[event.oldIndex]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Instead we'll move it by updating the underlying data structures.\r\n\t\t\t\t\tlet oldArray = getLoopElArray_(event.from);\r\n\t\t\t\t\tlet newArray = oldArray;\r\n\t\t\t\t\tif (event.from !== event.to)\r\n\t\t\t\t\t\tnewArray = getLoopElArray_(event.to);\r\n\r\n\r\n\t\t\t\t\tif (event.pullMode === 'clone')\r\n\t\t\t\t\t\titem = oldArray[event.oldIndex];\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\titem = oldArray.splice(event.oldIndex, 1)[0];\r\n\t\t\t\t\t}\r\n\r\n\r\n\r\n\t\t\t\t\t// TODO: RemoveProxies() from item.  Or modify the arra intercept functions to removeProxies() from all arguments?\r\n\t\t\t\t\tnewArray.splice(event.newIndex, 0, item.$removeProxy || item);\r\n\r\n\t\t\t\t\t// Update event.item, since we manually moved it above.\r\n\t\t\t\t\tevent.item = event.to.children[event.newIndex];\r\n\t\t\t\t}\r\n\r\n\t\t\t\r\n\r\n\t\t\t};\r\n\r\n\t\t\t// Intercept all events so we can set the proper \"this\" context when calling the callback.\r\n\t\t\tlet events = 'setData,onChoose,onUnchoose,onStart,onEnd,onAdd,onUpdate,onSort,onRemove,onFilter,onMove,onClone,onChange'.split(/,/g);\r\n\t\t\t//let events = ['onEnd'];\r\n\r\n\t\t\tfor (let eventName of events) {\r\n\r\n\t\t\t\tlet callback = options[eventName];\r\n\r\n\r\n\t\t\t\toptions[eventName] = function (event) {\r\n\t\t\t\t\tmoveItems(event);\r\n\t\t\t\t\tif (callback)\r\n\t\t\t\t\t \treturn callback.call(self, event);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tSortable.create(el, options);\r\n\t},\r\n\r\n\t/**\r\n\t * Special 2-way binding\r\n\t * @param self {XElement}\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement|HTMLInputElement}\r\n\t * @param context {object<string, string>} */\r\n\tval: (self, code, el, context) => {\r\n\t\tcode = addThis(replaceVars(code, context), context);\r\n\r\n\t\t// Update object property when input value changes, only if a simple var.\r\n\t\tvar paths = parseVars(code);\r\n\t\tif (paths.length === 1 && isStandaloneVar(code)) {\r\n\t\t\tlet onInput = () => {\r\n\t\t\t\tlet value = '';\r\n\t\t\t\tif (el.type === 'checkbox')\r\n\t\t\t\t\tvalue = el.checked;\r\n\t\t\t\telse if ('value' in el) // input, select\r\n\t\t\t\t\tvalue = el.value;\r\n\t\t\t\telse if (typeof el.innerHTML === 'string') // textarea, [contenteditable].  'innerHTML' in el evaluates to false, for unknown reasons.\r\n\t\t\t\t\tvalue = el.innerHTML;\r\n\r\n\t\t\t\t// We don't use watchlessSet in case other things are subscribed.\r\n\t\t\t\ttraversePath(self, paths[0], true, value);\r\n\t\t\t};\r\n\r\n\t\t\tel.addEventListener('input', onInput);\r\n\r\n\t\t\t// Add so this binding is removed when the element is unbound (but still exists),\r\n\t\t\t// such as when it moves to a different spot in a loop or from x-sortable.\r\n\t\t\t// Covered by test simpleBinding.val.unbind()\r\n\t\t\telEvents.add(el, ['input', onInput, null, self]);\r\n\t\t}\r\n\r\n\t\tfunction setVal(/*action, path, value*/) {\r\n\t\t\tlet result = safeEval.call(self, code, {el: el});\r\n\t\t\tif (result === undefined || result === null)\r\n\t\t\t\tresult = '';\r\n\r\n\t\t\tif (el.type === 'checkbox')\r\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\r\n\t\t\t\tel.checked = result == true;\r\n\t\t\telse if (el.hasAttribute('contenteditable')) {\r\n\t\t\t\tif (result !== el.innerHTML)\r\n\t\t\t\t\tel.innerHTML = result;\r\n\t\t\t}\r\n\t\t\telse if (el.value !== result)\r\n\t\t\t\tel.value = result;\r\n\t\t}\r\n\r\n\t\t// Update input value when object property changes.\r\n\t\tfor (let path of paths) {\r\n\t\t\tlet [root, pathFromRoot] = getRootXElement(self, path);\r\n\t\t\twatch(root, pathFromRoot, setVal);\r\n\t\t\telWatches.add(el, [root, pathFromRoot, setVal]);\r\n\t\t}\r\n\r\n\t\t// Set initial value.\r\n\t\tsetVal();\r\n\t},\r\n\r\n\t/**\r\n\t * @param self {XElement}\r\n\t * @param code {string}\r\n\t * @param el {HTMLElement}\r\n\t * @param context {object<string, string>} */\r\n\tvisible: (self, code, el, context) => {\r\n\t\tcode = addThis(replaceVars(code, context), context);\r\n\t\tvar displayNormal = el.style.display;\r\n\t\tif (displayNormal === 'none')\r\n\t\t\tdisplayNormal = '';\r\n\r\n\t\tlet setVisible = (/*action, path, value*/) => {\r\n\t\t\tel.style.display = safeEval.call(self, code, {el: el}) ? displayNormal : 'none';\r\n\t\t};\r\n\r\n\t\tfor (let path of parseVars(code)) {\r\n\t\t\tlet [root, pathFromRoot] = getRootXElement(self, path);\r\n\t\t\twatch(root, pathFromRoot, setVisible);\r\n\t\t\telWatches.add(el, [root, pathFromRoot, setVisible]);\r\n\t\t}\r\n\r\n\t\t// Set initial value.\r\n\t\tsetVisible();\r\n\t},\r\n\r\n\t/*\r\n\t'style': function(self, field, el) {}, // Can point to an object to use for the style.\r\n\t'if': function(self, field, el) {}, // Element is created or destroyed when data-if=\"code\" evaluates to true or false.\r\n\t*/\r\n};\r\n\r\nvar getLoopElArray_ = (loopEl, xparent) => {\r\n\txparent = xparent || getXParent(loopEl);\r\n\tlet context = loopEl.context_;\r\n\tlet foreach = parseLoop(getLoopCode_(loopEl))[0];\r\n\tforeach = addThis(replaceVars(foreach, context), context);\r\n\treturn safeEval.call(xparent, foreach, {el: loopEl});\r\n};\r\n\r\nexport {bindings};","/*\r\nInherit from XElement to create custom HTML Components.\r\n\r\n\r\nTODO: major bugfixes\r\nImporting css in an xelement doesn't apply unless the same css file is imported in the main document.\r\nRemoving a node that contains an xelement doesn't remove its items from elWatches or elsewhere?\r\n\tHow to unittest this, since I can't inspect what's in weakmap?\r\n\tThis can be tested in the test app by opening multiple programs.\r\nWrite a better parser for expr.replace(/this/g, 'parent');\r\nparseVars(\"this.passthrough(x)\") doesn't find x.\r\nparseVars(\"item + passthrough('')\") finds \"passthrough\" as a variable.\r\nWrite a getWatches(el, expr) function that calls replaceVars, addThis, parseVars, an getRootXElement\r\n\tto give back\r\nDocument all properties that bindings.loop() sets on elements.\r\nWon't bind to properties on the class itself, insead of those defined within constructor.  Because they are called after the super constructor!\r\nUse a regex or parser to remove the html of x-loops before they're passed to createEl().  This can remove the check at the top of initHtml() and the .initialized property.\r\nMake sure recursive embeds work if:  1. the x-loop is on the x-parent above the shadow dom.  2. An x-element is within a div inside the loop.\r\n\r\nTODO: next goals:\r\nAllow defining and assigning to id=\"\" properties only in the constructor, and only a null value or something.  That way TypeScript can know about them without throwing errors.\r\n\r\nrewrite loop code to let [key, value] = loop(array); or something that parses as valid javascript.  That way we can eventually make it a js language injection for IntelliJ.\r\nfor (const [key, value] of Object.entries(animals))\r\nfor (const [key, value] of loop(animals))\r\nStill very verbose compared to the current syntax.\r\n\r\nRemove proxy if name begins or ends with a $?  Warn about bound varaibles beginning with $.  And this will only work if the val is a proxy.  I need a way to let it do nothing if it's not a proxy.\r\nWhen an x-prop calls a function, and that function throws an error, we don't see it in chrome's stack trace.\r\n{{var}} in text and attributes, and stylesheets?\r\nFix failing Edge tests.\r\nallow comments in loops.\r\nx-elements in loops get fully initialized then replaced.  Is this still true?\r\n\r\n\r\n\r\n\r\nFinish making shadowdom optional.\r\n\r\nimplement other binding functions.\r\nallow loop over slots if data-loop is on the instantiation.\r\nallow loop over more than one html tag.\r\ncache results of parseVars() and other parse functions?\r\nfunctions to enable/disable updates.\r\nfunction to trigger updates?  Or a callback to apply all updates before DOM is updated.\r\n\r\ncreate from <template> tag\r\nWhen a change occurs, create a Set of functions to call, then later call them all.\r\n\tThat way we remove some duplicate updates.\r\nAuto bind to this in complex expressions if the class property already exists and the var is otherwise undefined?\r\nimprove minifcation.\r\nExpose bindings prop in minified version to allow plugins.\r\nnon-ascii variable names.\r\nthrottle, debounce? data-val only trigger on change.  \r\n\tE.g. x-val:debounce(100)=\"\"  x-visible:fadeIn(100)=\"\" x-visible:fadeOut(10)=\"\"\r\n\tor x-val=\"debounce(prop, 100)\" ?\r\n\tThe latter will be better accomodated by IDEs since there's not an infinite number of attribute names to add.\r\n\tIdeally it would support calling a function on change, after a debounce, with the before and after values.\r\n\t\tThis would make it easily pluggable into an undo/redo system.\r\n\tHow to handle debounce times in both directions?  Setting the prop to update the form, and setting the form value to update the prop?\r\nAuto two-way bind for simple variables?\r\nbind to <input type=\"file\">\r\nbind to drag and drop areas for files?\r\nbind to clipboard events\r\nNamed slot support? - https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots\r\nSeparate out a lite version that doesn't do binding?\r\n\tThis would also make the code easier to follow.  But what to call it?  XEl ? XElementLite?\r\nallow ${text} variables in nested styles?\r\nwarning on loop element id.\r\n\r\nDisadvantages of Vue.js\r\n10x larger.\r\nRequires a single, special root component everything else must be within.\r\nDoesn't use es6 classes.\r\nRequires data and methods, can't bind directly to class props.\r\nDoesn't support ShadowDOM, only emulates nested styles.\r\nRequires key=\"\" attributes everywhere to make identical elements unique.\r\nVue.js doesn't watch array indices or object property add/remove!\r\n   Every time you assign have to call Vue.set(array...)\r\ndata: {} items shared between each component instance, unless it's wrapped in a function.\r\nNo id's to class properties.\r\n\r\nAdvantages of Vue.js\r\nFast and debugged.\r\nWidespread use.\r\nIDE support\r\n---\r\n{{ templates }} for plain text.\r\ntransition effects\r\nAutomatically adds vendor prefixes for data-styles=\"\" binding.\r\nkey/value iteration over objects.\r\nCheckboxes and <select multiple> to array of names.\r\nlazy modifier for input binding, to only trigger update after change.\r\n\r\n*/\r\n\r\nimport {safeEval} from './safeEval.js';\r\nimport {eventNamesMap, isValidAttribute, traversePath, removeProxy} from './utils.js';\r\nimport {addThis, isStandaloneCall, parseVars, replaceVars} from './parseVars.js';\r\nimport {unwatch} from './watch.js';\r\nimport {bindings} from './bindings.js';\r\nimport {WeakMultiMap} from \"./WeakMultiMap.js\";\r\nimport {createEl} from \"./createEl.js\";\r\n\r\n/**\r\n * A map between elements and the callback functions subscribed to them.\r\n * Each value is an array of objects with path and callback function.\r\n * @type {WeakMultiMap<HTMLElement, {path_:string, callback_:function}[]>} */\r\nvar elWatches = new WeakMultiMap();\r\n\r\n\r\n/**\r\n * A map between elements and the events assigned to them. *\r\n * @type {WeakMultiMap<HTMLElement, *[]>} */\r\nvar elEvents = new WeakMultiMap();\r\n\r\n\r\n/**\r\n * @param cls {Function}\r\n * @returns {string} */\r\nvar getXName = (cls) => {\r\n\tif (!cls.xname_) {\r\n\t\tlet lname =  'x-' + cls.name.toLowerCase().replace(/^x/, '');\r\n\t\tcls.xname_ = lname;\r\n\r\n\t\t// If name exists, add an incrementing integer to the end.\r\n\t\t// TODO: Should I throw an error instead?\r\n\t\tfor (let i = 2; customElements.get(cls.xname_); i++)\r\n\t\t\tcls.xname_ = 'x-' + lname + i;\r\n\t}\r\n\treturn cls.xname_;\r\n};\r\n\r\n/**\r\n * Get the nearest XElement parent.\r\n * @param el {HTMLElement}\r\n * @returns {XElement} */\r\nvar getXParent = (el) => { // will error if not in an XParent.\r\n\twhile ((el = el.parentNode) && el && el.nodeType !== 11) {} // 11 is doc fragment\r\n\treturn el ? el.host : null;\r\n};\r\n\r\n\r\n/**\r\n * Follow the path to get the root XElement, returning it and the remaining path.\r\n * This is useful for watch()'ing the right elements with data-prop is used.\r\n * @param obj {object}\r\n * @param path {string[]}\r\n * @return {[XElement, string[]]} */\r\nvar getRootXElement = function(obj, path) {\r\n\tpath = path.slice();\r\n\tlet result = [obj, path.slice()];\r\n\r\n\t// Follow the path upward, assigning to obj at each step.\r\n\twhile (obj = obj[path.shift()])\r\n\t\tif (obj instanceof XElement)\r\n\t\t\tresult = [obj, path.slice()]; // .slice() to copy the path so that shift() doesn't modify our result.\r\n\r\n\treturn result;\r\n};\r\n\r\nvar getLoopCode_ = (el) => el.getAttribute && (el.getAttribute('x-loop') || el.getAttribute('data-loop'));\r\n\r\nvar getXAttrib = (el, name) => el.getAttribute && (el.getAttribute('x-' + name) || el.getAttribute('data-' + name));\r\n\r\nvar parseXAttrib = (name) => name.startsWith('x-') ? name.slice(2) : name.startsWith('data-') ? name.slice(5) : null;\r\n\r\n\r\nvar parseXAttrib2 = (name) => {\r\n\tvar parts = name.split(/:/g);\r\n\tvar functions = {};\r\n\tfor (let i=1; i<parts.length; i++) {\r\n\t\tlet [name, code] = parts[i].split('(');\r\n\t\tfunctions[name] = code.slice(0, -1); // remove trailing )\r\n\t}\r\n\treturn [parts[0], functions];\r\n};\r\n\r\n/**\r\n * Recursively process all the data- attributes in el and its descendants.\r\n * @param self {XElement}\r\n * @param el {HTMLElement}\r\n * @param context {object<string, string>[]=} A map of loop variable names to their absolute reference.\r\n * This allows us to do variable replacement:\r\n *     <div>data-loop=\"this.items : item\">\r\n *         <div data-val=\"item.name\">\r\n *  The looped item becomes:\r\n *         <div data-val=\"this.items[0].name\"> */\r\nvar bindEl = (self, el, context) => {\r\n\r\n\tbindElProps(self, el, context);\r\n\tbindElEvents(self, el, context, true);\r\n\r\n\t// TODO: assert() to make sure element isn't bound twice.\r\n};\r\n\r\n\r\nvar bindElProps = (xelement, el, context) => {\r\n\tcontext = context || [];\r\n\tcontext = context.slice();\r\n\r\n\r\n\t// Handle data-prop and\r\n\tif (el instanceof XElement) {\r\n\r\n\t\t// Bind instantiation attributes (to the parent, not ourselves)\r\n\t\tif (el !== xelement)\r\n\t\t\tfor (let attrName in el.instantiationAttributes) {\r\n\t\t\t\tlet val = el.instantiationAttributes[attrName];\r\n\t\t\t\tlet name = parseXAttrib(attrName);\r\n\t\t\t\tif (name && name !== 'prop') { // prop handled in init so it happens first.\r\n\t\t\t\t\tif (bindings[name]) // attr.value is code.\r\n\t\t\t\t\t\tbindings[name](xelement, val, el, context);\r\n\r\n\t\t\t\t\t//#IFDEV\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tthrow new XElementError(attrName);\r\n\t\t\t\t\t//#ENDIF\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t// Don't inherit within-element context from parent.\r\n\t\tel.propContext = (xelement.propContext || []).slice();\r\n\r\n\t\tlet prop = getXAttrib(el, 'prop');\r\n\t\tif (prop) {\r\n\r\n\t\t\t// Here we still need to use the inner context of the parent XElement because\r\n\t\t\t// prop may have variables within it that may need to be resolved.\r\n\t\t\tbindings.prop(xelement, prop, el, context); // adds a new context to the beginning of the array.\r\n\r\n\t\t\t// Then we add the new context item added by prop();\r\n\t\t\tcontext = [context[0], ...el.propContext];\r\n\t\t}\r\n\t\telse\r\n\t\t\tcontext = el.propContext.slice();\r\n\r\n\r\n\r\n\t\tfor (let attrName in el.definitionAttributes) {\r\n\t\t\tlet val = el.definitionAttributes[attrName];\r\n\t\t\tlet name = parseXAttrib(attrName);\r\n\t\t\tif (name && name !== 'prop') { // prop handled in init so it happens first.\r\n\t\t\t\tif (bindings[name]) // attr.value is code.\r\n\t\t\t\t\tbindings[name](el, val, el, context);\r\n\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow new XElementError(attrName);\r\n\t\t\t\t//#ENDIF\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\txelement = el;\r\n\t}\r\n\r\n\r\n\t// Seach attributes for data- bindings.\r\n\telse if (el.attributes) { // shadow root has no attributes.\r\n\t\tfor (let attr of el.attributes) {\r\n\t\t\tlet attrName = parseXAttrib(attr.name);\r\n\t\t\tif (attrName && attrName !== 'prop') { // prop handled in init so it happens first.\r\n\t\t\t\tif (bindings[attrName]) // attr.value is code.\r\n\t\t\t\t\tbindings[attrName](xelement, attr.value, el, context);\r\n\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow new XElementError(attrName);\r\n\t\t\t\t//#ENDIF\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\t// Data loop already binds its own children when first applied.\r\n\t// So we don't iterate into those children.\r\n\tif (!getLoopCode_(el)) {\r\n\r\n\t\t// Allow traversing from host element into its own shadowRoot\r\n\t\tlet next = el.shadowRoot || el;\r\n\r\n\t\tfor (let child of next.children)\r\n\t\t\tbindElProps(xelement, child, context);\r\n\t}\r\n};\r\n\r\n\r\n\r\n/**\r\n * We rebind event attributes because otherwise there's no way\r\n * to make them call the class methods.\r\n * @param xelement {XElement}\r\n * @param el {HTMLElement}\r\n * @param context {object<string, string>=}\r\n * @param recurse {boolean=false}\r\n * @param getAttributesFrom {HTMLElement=} */\r\nvar bindElEvents = (xelement, el, context, recurse, getAttributesFrom) => {\r\n\r\n\r\n\tgetAttributesFrom = getAttributesFrom || el;\r\n\tif (getAttributesFrom.getAttribute) { // if not document fragment\r\n\r\n\t\t// Make copy because we remove them as we go.\r\n\t\tvar attribs = Array.prototype.slice.call(getAttributesFrom.attributes);\r\n\t\tfor (let attrib of attribs) {\r\n\r\n\t\t\tif (attrib.name in eventNamesMap) {\r\n\r\n\t\t\t\tlet eventName = attrib.name.substr(2); // remove \"on\" prefix.\r\n\t\t\t\tlet originalEventAttrib = attrib.value;\r\n\r\n\t\t\t\tlet code = replaceVars(originalEventAttrib, context);\r\n\r\n\t\t\t\t// If it's a simple function that exists in the class,\r\n\t\t\t\t// add the \"this\" prefix.\r\n\t\t\t\tlet path = parseVars(code, 0, 1)[0];\r\n\t\t\t\tif (path && traversePath(xelement, path) instanceof Function)\r\n\t\t\t\t\tcode = addThis(code, context, isStandaloneCall);\r\n\r\n\t\t\t\t// The code in the attribute can reference:\r\n\t\t\t\t// 1. event, assigned to the current event.\r\n\t\t\t\t// 2. this, assigned to the class instance.\r\n\t\t\t\tlet callback = function (event) {\r\n\r\n\t\t\t\t\teval(code);\r\n\r\n\t\t\t\t\t// TODO: Make safeEval() work here.  It currently fails bc it has the wrong xelement.\r\n\t\t\t\t\t// Try this again after we redo event binding in initHtml().\r\n\t\t\t\t\t//safeEval.call(xelement, code, {event: event}, true);\r\n\t\t\t\t}.bind(xelement);\r\n\r\n\t\t\t\tel.addEventListener(eventName, callback);\r\n\r\n\t\t\t\t// Save everything we'll need to restore it later.\r\n\t\t\t\telEvents.add(el, [eventName, callback, originalEventAttrib, xelement]);\r\n\r\n\t\t\t\t// Remove the original version so it doesn't also fire.\r\n\t\t\t\tel.removeAttribute(attrib.name);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (recurse) {\r\n\t\t// Allow traversing from host element into its own shadowRoot\r\n\t\tlet next = el.shadowRoot || el;\r\n\t\tif (el instanceof XElement)\r\n\t\t\txelement = el;\r\n\r\n\t\t// data-loop handles its own children.\r\n\t\tif (!getLoopCode_(next))\r\n\t\t\tfor (let child of next.children)\r\n\t\t\t\tbindElEvents(xelement, child, context, true);\r\n\t}\r\n};\r\n\r\n\r\n\r\n\r\n/**\r\n * Unbind properties and events from the element.\r\n * @param xelement {XElement|HTMLElement}\r\n * @param el {HTMLElement=} Remove all bindings within root and children. Defaults to self. */\r\nvar unbindEl = (xelement, el) => {\r\n\tel = el || xelement;\r\n\r\n\tvar next = el.shadowRoot || el;\r\n\r\n\t// Recursively unbind children.\r\n\tfor (let child of next.children) {\r\n\r\n\t\t// Change xelement reference as we descend into other xelements.\r\n\t\t// This is needed for test prop.unbindChild()\r\n\t\tif (child instanceof XElement)\r\n\t\t\tunbindEl(child, child);\r\n\t\telse\r\n\t\t\tunbindEl(xelement, child);\r\n\t}\r\n\r\n\t// Unbind properties\r\n\tif (el.attributes)\r\n\t\tfor (let attr of el.attributes) {\r\n\t\t\tif (attr.name.startsWith('x-') || attr.name.startsWith('data-')) {\r\n\r\n\t\t\t\tif ((attr.name === 'x-loop' || attr.name === 'data-loop') && el.loopHtml_) {\r\n\t\t\t\t\tel.innerHTML = el.loopHtml_; // revert it back to the look template element.\r\n\t\t\t\t\tdelete el.loopHtml_;\r\n\t\t\t\t\tdelete el.items_;\r\n\t\t\t\t\tdelete el.context_;\r\n\t\t\t\t\tdelete el.propContext;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// New\r\n\t\t\t\tlet watches = elWatches.getAll(el);\r\n\t\t\t\tfor (let w of watches)\r\n\t\t\t\t\tunwatch(...w);\r\n\t\t\t\telWatches.removeAll(el);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t// Unbind events\r\n\tlet ee = elEvents.getAll(el) || [];\r\n\tfor (let item of ee) { //  item is [event:string, callback:function, originalCode:string, root:XElement]\r\n\r\n\t\t// Only unbind if it was bound from the same root.\r\n\t\t// This is needed to allow onclick=\"\" attributes on both the definition and instantiation of an element,\r\n\t\t// and having their \"this\" bound to themselves or the parent element, respectively.\r\n\t\tif (item[3] === xelement) {\r\n\t\t\tel.removeEventListener(item[0], item[1]);\r\n\t\t\tif (item[2])\r\n\t\t\t\tel.setAttribute('on' + item[0], item[2]);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\nvar setAttribute = (self, name, value) => {\r\n\r\n\t// Copy to class properties.\r\n\t// This doesn't work because the properties aren't created until after initHtml() is called.\r\n\tif (!isValidAttribute(self, name)) {\r\n\r\n\t\t// As javascript code to be evaluated.\r\n\t\t// TODO: Should this feature be deprecated or moved to data-properties  Overlap with data-prop?\r\n\t\tif (value && value.length > 2 && value.startsWith('{') && value.endsWith('}')) {\r\n\t\t\tself[name] = safeEval.call(self, value.slice(1, -1)); // code to eval\r\n\t\t}\r\n\t\telse\r\n\t\t\tself[name] = value;\r\n\t}\r\n\r\n\t// Copy attribute as an attribute.\r\n\telse\r\n\t\tself.setAttribute(name, value);\r\n};\r\n\r\n\r\nvar initHtml = (self) => {\r\n\r\n\tif (!self.init_) {\r\n\r\n\t\tself.init_ = 1;\r\n\r\n\t\t//#IFDEV\r\n\t\tif (!self.constructor.html_)\r\n\t\t\tthrow new XElementError('XElement .html property must be set to a non-empty string.');\r\n\t\t//#ENDIF\r\n\r\n\t\t// If a child of a loop, before loop is initialized.\r\n\t\tif (self.parentNode && getXAttrib(self.parentNode, 'loop')) {\r\n\t\t\tself.parentNode.loopHtml = self.constructor.html_.trim();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 1. Create temporary element.\r\n\t\tXElement.disableBind++;\r\n\t\tvar definition = createEl(self.constructor.html_.trim()); // html_ is set from ClassName.html = '...'\r\n\t\tXElement.disableBind--;\r\n\r\n\r\n\t\t// Save definition attributes\r\n\t\tfor (let attr of definition.attributes)\r\n\t\t\tself.definitionAttributes[attr.name] = attr.value;\r\n\r\n\t\t// 2. Remove and save attributes from instantiation.\r\n\t\tfor (let attr of self.attributes) // From instantiation.\r\n\t\t\tself.instantiationAttributes[attr.name] = attr.value;\r\n\r\n\t\t// 3.  Add attributes from definition (Item.html='<div attr=\"value\"')\r\n\t\tfor (let attr of definition.attributes) { // From definition\r\n\t\t\tif (attr.name)\r\n\t\t\t\tsetAttribute(self, attr.name, attr.value);\r\n\t\t}\r\n\r\n\t\t// 4. Bind events on the defintion to functions on its own element and not its container\r\n\t\t// TODO: Remove this line and make the bindElEvents() smart enough to know what to do on its own, like we did with bindElProps()\r\n\t\tbindElEvents(self, self, null, false, definition);\r\n\r\n\t\t// 5.  Add attributes from instantiation.\r\n\t\tfor (let name in self.instantiationAttributes) // From instantiation\r\n\t\t\tsetAttribute(self, name, self.instantiationAttributes[name]);\r\n\r\n\t\t// 6. Create children\r\n\r\n\t\t// As Shadow DOM\r\n\t\tlet mode = self.constructor.shadowMode;\r\n\t\tif (!mode)\r\n\t\t\tmode = 'open';\r\n\r\n\t\tif (mode === 'open' || mode === 'closed') {\r\n\t\t\tself.attachShadow({mode: mode});\r\n\t\t\twhile (definition.firstChild)\r\n\t\t\t\tself.shadowRoot.insertBefore(definition.firstChild, null);\r\n\r\n\t\t}\r\n\t\telse { // mode == 'none'\r\n\r\n\t\t\t// without\r\n\t\t\t// Html within <x-classname>...</x-classname>, where the tag is added to another element.\r\n\t\t\t// This only works in the Edge shim.  It's an empty string in chrome and firefox.\r\n\t\t\tvar slotHtml = self.innerHTML;\r\n\t\t\tvar slot = definition.querySelector('#slot');\r\n\t\t\tif (slot)\r\n\t\t\t\tslot.removeAttribute('id');\r\n\r\n\t\t\t// Copy children from temporary div to this class.\r\n\t\t\tif (slot || !slotHtml) {\r\n\t\t\t\tself.innerHTML = '';\r\n\t\t\t\twhile (definition.firstChild)\r\n\t\t\t\t\tself.appendChild(definition.firstChild);\r\n\t\t\t}\r\n\r\n\t\t\t// Copy children from <x-classname> into the slot.\r\n\t\t\tif (slotHtml)\r\n\t\t\t\t(slot || self).innerHTML = slotHtml;\r\n\t\t}\r\n\r\n\t\tvar root = self.shadowRoot || self;\r\n\r\n\t\t// 7. replace link tags with inline styles, if the style has already been added to the outermost document.\r\n\t\t// This prevents making an http request for each one when the server doesn't have caching.  (e.g. during development)\r\n\t\tfor (let link of root.querySelectorAll('link')) {\r\n\t\t\tfor (let stylesheet of document.styleSheets)\r\n\t\t\t\tif (stylesheet.href === link.href) {\r\n\t\t\t\t\tlink.parentNode.replaceChild(\r\n\t\t\t\t\t\tXElement.createEl(\r\n\t\t\t\t\t\t\t'<style>' +\r\n\t\t\t\t\t\t\tArray.from(stylesheet.cssRules).map(x => x.cssText).join('\\n') +\r\n\t\t\t\t\t\t\t'</style>'),\r\n\t\t\t\t\t\tlink);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// 8. Create class properties that reference any html element with an id tag.\r\n\t\tfor (let node of root.querySelectorAll('[id]')) {\r\n\t\t\tlet id = node.getAttribute('id');\r\n\r\n\t\t\t//#IFDEV\r\n\t\t\t// Make sure we're not replacing an existing method.\r\n\t\t\tif (id in self && self[id] instanceof Function)\r\n\t\t\t\tthrow new XElementError('Cannot set property \"' + id + '\" on \"' + self.constructor.name +\r\n\t\t\t\t\t'\" because there is already a class method with the same name.');\r\n\t\t\t//#ENDIF\r\n\r\n\t\t\tObject.defineProperty(self, id, {\r\n\t\t\t\t// Make it readonly.\r\n\t\t\t\t// Using writeable: false caused errors if the getter returns a proxy instead of the proper type.\r\n\t\t\t\t// But how does it know it's the wrong type?\r\n\r\n\t\t\t\tenumerable: 1,\r\n\t\t\t\tconfigurable: 1,\r\n\t\t\t\tget: () => node,\r\n\t\t\t\t//#IFDEV\r\n\t\t\t\tset: () => {\r\n\t\t\t\t\tthrow new XElementError('Property ' + id + ' not writable');\r\n\t\t\t\t}\r\n\t\t\t\t//#ENDIF\r\n\t\t\t});\r\n\r\n\t\t\t// Only leave the id attributes if we have a shadow root.\r\n\t\t\t// Otherwise we'll have duplicate id's in the main document.\r\n\t\t\tif (!self.shadowRoot)\r\n\t\t\t\tnode.removeAttribute('id');\r\n\t\t}\r\n\r\n\r\n\t\tif (XElement.disableBind === 0) {\r\n\r\n\t\t\t// 9. Bind all data- and event attributes\r\n\t\t\t// TODO: Move bind into setAttribute above, so we can call it separately for definition and instantiation?\r\n\t\t\tbindElProps(self, self);\r\n\r\n\r\n\t\t\t// We pass root to bind all events on this element's children.\r\n\t\t\t// We bound events on the element itself in a separate call to bindElEvents(self, self) above.\r\n\t\t\tbindElEvents(self, root, null, true);\r\n\t\t}\r\n\r\n\t\tself.initialized = true;\r\n\t}\r\n};\r\n\r\n/**\r\n * @extends HTMLElement\r\n * @extends Node\r\n * @property {HTMLElement} shadowRoot\r\n * Inherit from this class to make a custom HTML element.\r\n * If you extend from XElement, you can't instantiate your class unless you first set the html property.\r\n * This is because XElement extends from HTMLElement, and setting the .html property calls customElements.define(). */\r\nclass XElement extends HTMLElement {\r\n\r\n\tconstructor() {\r\n\t\t//#IFDEV\r\n\t\ttry {\r\n\t\t\t//#ENDIF\r\n\t\t\tsuper();\r\n\t\t\t//#IFDEV\r\n\t\t} catch (error) {\r\n\t\t\tif (error instanceof TypeError) // Add helpful message to error:\r\n\t\t\t\terror.message += '\\nMake sure to set the .html property before instantiating the class \"' + this.name + '\".';\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t\t//#ENDIF\r\n\r\n\t\t// Class properties\r\n\t\tthis.parent = undefined;\r\n\t\tthis.definitionAttributes = {};\r\n\t\tthis.instantiationAttributes = {};\r\n\r\n\r\n\t\tlet xname = getXName(this.constructor);\r\n\t\tlet self = this;\r\n\t\tif (customElements.get(xname))\r\n\t\t\tinitHtml(self);\r\n\t\telse\r\n\t\t\tcustomElements.whenDefined(xname).then(() => {\r\n\t\t\t\tinitHtml(self);\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * TODO: Use this function in more places.\r\n\t * @param expr {string}\r\n\t * @param context {object[]}\r\n\t * @returns {[XElement, string[]][]} Array of arrays, with each sub-array being a root and the path from it.  */\r\n\tgetWatchedPaths(expr, context) {\r\n\t\texpr = addThis(replaceVars(expr, context), context);\r\n\t\treturn parseVars(expr).map(\r\n\t\t\t(path)=>getRootXElement(this, path)\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Override the static html property so we can call customElements.define() whenever the html is set.*/\r\nObject.defineProperty(XElement, 'html', {\r\n\tget: () => this.html_,\r\n\tset: function (html) {\r\n\r\n\t\t// TODO: We want to be able to do:\r\n\t\t// <x-item arg1=\"1\", arg2=\"2\">\r\n\t\t// And have those passed to Item's constructor.\r\n\t\t// Here we can get the names of those arguments, but how to intercept the browser's call to the constructor?\r\n\t\t// Below I tried to work around this by subclassing.\r\n\t\t// But we can't get a reference to the <x-item> to read its attributes before the super() call.\r\n\t\t// const self = this;\r\n\t\t// function getConstructorArgs(func) {\r\n\t\t// \treturn func.toString()  // stackoverflow.com/a/14660057\r\n\t\t// \t\t.replace(/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,'') // Remove comments. TODO: Also remove strings.\r\n\t\t// \t\t.match(/^\\s*constructor\\s*\\(\\s*([^)]*)\\)\\s*{/m)[1] // submatch \"constructor(...) {\"\r\n\t\t// \t\t.split(/\\s*,\\s*/);\r\n\t\t// }\r\n\t\t// var args = getConstructorArgs(this);\r\n\t\t//\r\n\t\t// class Embedded extends this {\r\n\t\t// \tconstructor() {\r\n\t\t// \t\tvar attrib0 = this.getAttribute(args[0]); // fails.  Can't use \"this\".\r\n\t\t// \t\tsuper(attrib0);\r\n\t\t// \t}\r\n\t\t// }\r\n\r\n\t\t// Could the customElements.whenDefined() callback be helpful?\r\n\r\n\t\t// New way where we pass attributes to the constructor:\r\n\t\t// customElements.define(name, Embedded);\r\n\t\t// customElements.define(name+'-internal', this);\r\n\r\n\t\t// Old way:\r\n\t\tcustomElements.define(getXName(this), this);\r\n\r\n\t\treturn this.html_ = html.trim();\r\n\t}\r\n});\r\n\r\n// Exports\r\nXElement.disableBind = 0;\r\nXElement.bindings = bindings;\r\nXElement.createEl = createEl; // useful for other code.\r\nXElement.getXParent = getXParent;\r\nXElement.removeProxy = removeProxy;\r\n\r\nXElement.cleanup = () => {\r\n\telWatches = new WeakMultiMap();\r\n\telEvents = new WeakMultiMap();\r\n};\r\n\r\nexport { XElement, getRootXElement, getXParent, elWatches, elEvents, bindEl, unbindEl };\r\nexport {removeProxy, unwatch};\r\n\r\n// Used as a passthrough for xelement attrib debugging.\r\nwindow.xdebug = (a) => {\r\n\tdebugger;\r\n\treturn a;\r\n};\r\nwindow.xlog = (a) => {\r\n\tconsole.log(a);\r\n\treturn a;\r\n};"],"names":["Cache","self","this","map","Map","get","key","val","result","set","safeEvalCache","safeEval","expr","args","isStatements","code","Object","keys","length","argAssignments","name","push","replace","join","lazyEval","Function","call","e","TypeError","message","match","eventNames","document","__proto__","filter","x","startsWith","slice","eventNamesMap","eventName","XElementError","Error","[object Object]","msg","super","removeProxy","obj","$removeProxy","arrayEq","array1","array2","deep","every","value","index","Array","isArray","csv","array","JSON","stringify","isObj","isValidAttribute","el","hasAttribute","includes","isAttr","hasKeyStartingWith","prefix","traversePath","path","create","watchless","i","srcProp","last","undefined","$disableWatch","removeProxies","visited","$isProxy","has","WeakSet","add","t","v","getOwnPropertyDescriptor","writable","wp","watch","objects","fields_","identifier","dotIdentifier","varBrD","varBrS","varNum","or","varProp","or2","varPropOrFunc","isStandaloneVarRegex","RegExp","isSimpleCallRegex","varStartRegex","varPropRegex","nonVars","split","nonVars2","isStandaloneVar","trim","isStandaloneCall","semi","indexOf","parseVars","includeThis","allowCall","item","matches","regex","keepGoing","currentVar","index_","exec","lastIndex","endsWith","Boolean","start","end","trimThis","replaceVars","replacements","replacement","oldVar","paths","reverse","parseObj","pieces","piece","colon","parseLoop","addThis","context","isStandalone","contextVars","pre","window","arrayRead","arrayWrite","handler","field","roots","WatchUtil","getRoots","root","notifyCallbacks","from","callbacks_","reduce","a","b","Symbol","iterator","obj2","bind","parentPaths","getPaths","parentPath","addPath","getProxy","newVal","oldVal","splice","proxy","proxies","Proxy","func","defineProperty","enumerable","prototype","configurable","originalLength","startIndex","arguments","apply","rebuildArray","oldPath","newPath","j","Set","objMap","WeakMap","existingPath","l","same","addCallback","callback","callbacks","getCallbacks","action","cleanup","watchProxy","WatchProperties","obj_","proxy_","notify_","subs_","cpath","parentCPath","pop","subPath","oldSubPath","parse","oldSubVal","newSubVal","fullSubPath","callbackIndex","propCpath","subscribe_","unwatch","unsubscribe_","sub","delete","WeakMultiMap","items","itemSet","getAll","remove","removeAll","createElMap","createEl","html","existing","cloneNode","tagName","parentTag","td","tr","tbody","thead","tfoot","source","area","legend","option","col","param","parent","createElement","innerHTML","removeChild","firstChild","elWatches","elEvents","getXName","cls","xname_","lname","toLowerCase","customElements","getXParent","parentNode","nodeType","host","getRootXElement","shift","XElement","getLoopCode_","getAttribute","getXAttrib","parseXAttrib","bindEl","bindElProps","bindElEvents","xelement","attrName","instantiationAttributes","bindings","propContext","prop","definitionAttributes","attributes","attr","next","shadowRoot","child","children","recurse","getAttributesFrom","attribs","attrib","substr","originalEventAttrib","event","eval","addEventListener","removeAttribute","unbindEl","loopHtml_","items_","context_","watches","w","ee","removeEventListener","setAttribute","initHtml","init_","constructor","html_","loopHtml","disableBind","definition","mode","shadowMode","attachShadow","insertBefore","slotHtml","slot","querySelector","appendChild","link","querySelectorAll","stylesheet","styleSheets","href","replaceChild","cssRules","cssText","node","id","initialized","HTMLElement","error","xname","whenDefined","then","define","xdebug","xlog","console","log","attrExpr","setAttr","pathFromRoot","classes","classExpr","updateClass","classList","text","setText","textContent","setHtml","loop","foreach","loopVar","indexVar","rebuildChildren","indirect","outerHTML","lastChild","newItems","oldItems","oldMap","newSet","oldItem","oldChild","newChild","isNew","localContext","newContext","expr2","descriptor","unshift","sortable","options","loopCode","moveItems","type","pullMode","to","newIndex","oldIndex","oldArray","getLoopElArray_","newArray","events","Sortable","onInput","checked","setVal","visible","displayNormal","style","display","setVisible","loopEl","xparent"],"mappings":"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"}